/*****************************************************************************
 * Copyright (C) Queen's University Belfast, ECIT, 2016                      *
 *                                                                           *
 * This file is part of libsafecrypto.                                       *
 *                                                                           *
 * This file is subject to the terms and conditions defined in the file      *
 * 'LICENSE', which is part of this source code package.                     *
 *****************************************************************************/

/*
 * Git commit information:
 *   Author: $SC_AUTHOR$
 *   Date:   $SC_DATE$
 *   Branch: $SC_BRANCH$
 *   Id:     $SC_IDENT$
 */

#include "utils/arith/gpv.h"
#include "utils/arith/sc_poly_mpz.h"
#include "utils/arith/sc_mpz.h"
#include "utils/crypto/prng.h"
#include "utils/arith/sc_math.h"
#include "utils/arith/arith.h"
#include "utils/sampling/sampling.h"
#include "safecrypto_types.h"
#include "safecrypto_private.h"
#include "safecrypto_debug.h"
#include "safecrypto_error.h"
#include "poly_fft.h"
#include "utils/arith/falcon_fft.h"
#include "utils/arith/falcon_ldl.h"

#include "schemes/sig/falcon/falcon_params.h"
#include "schemes/sig/ens_dlp/ens_dlp_sig_params.h"
#include "schemes/ibe/dlp/dlp_ibe_params.h"

#define NTT_NEEDS_12289
#include "utils/arith/ntt_tables.h"

#include <math.h>

#define DEBUG_GPV               0
#define CRT_NTRU_SOLVE          1


typedef struct {
        uint32_t p;
        uint32_t g;
        uint32_t s;
} small_prime_t;

static const small_prime_t binary_primes[] = {
        { 2147473409,  383167813,      10239 },
        { 2147389441,  211808905,  471403745 },
        { 2147387393,   37672282, 1329335065 },
        { 2147377153, 1977035326,  968223422 },
        { 2147358721, 1067163706,  132460015 },
        { 2147352577, 1606082042,  598693809 },
        { 2147346433, 2033915641, 1056257184 },
        { 2147338241, 1653770625,  421286710 },
        { 2147309569,  631200819, 1111201074 },
        { 2147297281, 2038364663, 1042003613 },
        { 2147295233, 1962540515,   19440033 },
        { 2147239937, 2100082663,  353296760 },
        { 2147235841, 1991153006, 1703918027 },
        { 2147217409,  516405114, 1258919613 },
        { 2147205121,  409347988, 1089726929 },
        { 2147196929,  927788991, 1946238668 },
        { 2147178497, 1136922411, 1347028164 },
        { 2147100673,  868626236,  701164723 },
        { 2147082241, 1897279176,  617820870 },
        { 2147074049, 1888819123,  158382189 },
        { 2147051521,   25006327,  522758543 },
        { 2147043329,  327546255,   37227845 },
        { 2147039233,  766324424, 1133356428 },
        { 2146988033, 1862817362,   73861329 },
        { 2146963457,  404622040,  653019435 },
        { 2146959361, 1936581214,  995143093 },
        { 2146938881, 1559770096,  634921513 },
        { 2146908161,  422623708, 1985060172 },
        { 2146885633, 1751189170,  298238186 },
        { 2146871297,  578919515,  291810829 },
        { 2146846721, 1114060353,  915902322 },
        { 2146834433, 2069565474,   47859524 },
        { 2146818049, 1552824584,  646281055 },
        { 2146775041, 1906267847, 1597832891 },
        { 2146756609, 1847414714, 1228090888 },
        { 2146744321, 1818792070, 1176377637 },
        { 2146738177, 1118066398, 1054971214 },
        { 2146736129,   52057278,  933422153 },
        { 2146713601,  592259376, 1406621510 },
        { 2146695169,  263161877, 1514178701 },
        { 2146656257,  685363115,  384505091 },
        { 2146650113,  927727032,  537575289 },
        { 2146646017,   52575506, 1799464037 },
        { 2146643969, 1276803876, 1348954416 },
        { 2146603009,  814028633, 1521547704 },
        { 2146572289, 1846678872, 1310832121 },
        { 2146547713,  919368090, 1019041349 },
        { 2146508801,  671847612,   38582496 },
        { 2146492417,  283911680,  532424562 },
        { 2146490369, 1780044827,  896447978 },
        { 2146459649,  327980850, 1327906900 },
        { 2146447361, 1310561493,  958645253 },
        { 2146441217,  412148926,  287271128 },
        { 2146437121,  293186449, 2009822534 },
        { 2146430977,  179034356, 1359155584 },
        { 2146418689, 1517345488, 1790248672 },
        { 2146406401, 1615820390, 1584833571 },
        { 2146404353,  826651445,  607120498 },
        { 2146379777,    3816988, 1897049071 },
        { 2146363393, 1221409784, 1986921567 },
        { 2146355201, 1388081168,  849968120 },
        { 2146336769, 1803473237, 1655544036 },
        { 2146312193, 1023484977,  273671831 },
        { 2146293761, 1074591448,  467406983 },
        { 2146283521,  831604668, 1523950494 },
        { 2146203649,  712865423, 1170834574 },
        { 2146154497, 1764991362, 1064856763 },
        { 2146142209,  627386213, 1406840151 },
        { 2146127873, 1638674429, 2088393537 },
        { 2146099201, 1516001018,  690673370 },
        { 2146093057, 1294931393,  315136610 },
        { 2146091009, 1942399533,  973539425 },
        { 2146078721, 1843461814, 2132275436 },
        { 2146060289, 1098740778,  360423481 },
        { 2146048001, 1617213232, 1951981294 },
        { 2146041857, 1805783169, 2075683489 },
        { 2146019329,  272027909, 1753219918 },
        { 2145986561, 1206530344, 2034028118 },
        { 2145976321, 1243769360, 1173377644 },
        { 2145964033,  887200839, 1281344586 },
        { 2145906689, 1651026455,  906178216 },
        { 2145875969, 1673238256, 1043521212 },
        { 2145871873, 1226591210, 1399796492 },
        { 2145841153, 1465353397, 1324527802 },
        { 2145832961, 1150638905,  554084759 },
        { 2145816577,  221601706,  427340863 },
        { 2145785857,  608896761,  316590738 },
        { 2145755137, 1712054942, 1684294304 },
        { 2145742849, 1302302867,  724873116 },
        { 2145728513,  516717693,  431671476 },
        { 2145699841,  524575579, 1619722537 },
        { 2145691649, 1925625239,  982974435 },
        { 2145687553,  463795662, 1293154300 },
        { 2145673217,  771716636,  881778029 },
        { 2145630209, 1509556977,  837364988 },
        { 2145595393,  229091856,  851648427 },
        { 2145587201, 1796903241,  635342424 },
        { 2145525761,  715310882, 1677228081 },
        { 2145495041, 1040930522,  200685896 },
        { 2145466369,  949804237, 1809146322 },
        { 2145445889, 1673903706,   95316881 },
        { 2145390593,  806941852, 1428671135 },
        { 2145372161, 1402525292,  159350694 },
        { 2145361921, 2124760298, 1589134749 },
        { 2145359873, 1217503067, 1561543010 },
        { 2145355777,  338341402,   83865711 },
        { 2145343489, 1381532164,  641430002 },
        { 2145325057, 1883895478, 1528469895 },
        { 2145318913, 1335370424,   65809740 },
        { 2145312769, 2000008042, 1919775760 },
        { 2145300481,  961450962, 1229540578 },
        { 2145282049,  910466767, 1964062701 },
        { 2145232897,  816527501,  450152063 },
        { 2145218561, 1435128058, 1794509700 },
        { 2145187841,   33505311, 1272467582 },
        { 2145181697,  269767433, 1380363849 },
        { 2145175553,   56386299, 1316870546 },
        { 2145079297, 2106880293, 1391797340 },
        { 2145021953, 1347906152,  720510798 },
        { 2145015809,  206769262, 1651459955 },
        { 2145003521, 1885513236, 1393381284 },
        { 2144960513, 1810381315,   31937275 },
        { 2144944129, 1306487838, 2019419520 },
        { 2144935937,   37304730, 1841489054 },
        { 2144894977, 1601434616,  157985831 },
        { 2144888833,   98749330, 2128592228 },
        { 2144880641, 1772327002, 2076128344 },
        { 2144864257, 1404514762, 2029969964 },
        { 2144827393,  801236594,  406627220 },
        { 2144806913,  349217443, 1501080290 },
        { 2144796673, 1542656776, 2084736519 },
        { 2144778241, 1210734884, 1746416203 },
        { 2144759809, 1146598851,  716464489 },
        { 2144757761,  286328400, 1823728177 },
        { 2144729089, 1347555695, 1836644881 },
        { 2144727041, 1795703790,  520296412 },
        { 2144696321, 1302475157,  852964281 },
        { 2144667649, 1075877614,  504992927 },
        { 2144573441,  198765808, 1617144982 },
        { 2144555009,  321528767,  155821259 },
        { 2144550913,  814139516, 1819937644 },
        { 2144536577,  571143206,  962942255 },
        { 2144524289, 1746733766,    2471321 },
        { 2144512001, 1821415077,  124190939 },
        { 2144468993,  917871546, 1260072806 },
        { 2144458753,  378417981, 1569240563 },
        { 2144421889,  175229668, 1825620763 },
        { 2144409601, 1699216963,  351648117 },
        { 2144370689, 1071885991,  958186029 },
        { 2144348161, 1763151227,  540353574 },
        { 2144335873, 1060214804,  919598847 },
        { 2144329729,  663515846, 1448552668 },
        { 2144327681, 1057776305,  590222840 },
        { 2144309249, 1705149168, 1459294624 },
        { 2144296961,  325823721, 1649016934 },
        { 2144290817,  738775789,  447427206 },
        { 2144243713,  962347618,  893050215 },
        { 2144237569, 1655257077,  900860862 },
        { 2144161793,  242206694, 1567868672 },
        { 2144155649,  769415308, 1247993134 },
        { 2144137217,  320492023,  515841070 },
        { 2144120833, 1639388522,  770877302 },
        { 2144071681, 1761785233,  964296120 },
        { 2144065537,  419817825,  204564472 },
        { 2144028673,  666050597, 2091019760 },
        { 2144010241, 1413657615, 1518702610 },
        { 2143952897, 1238327946,  475672271 },
        { 2143940609,  307063413, 1176750846 },
        { 2143918081, 2062905559,  786785803 },
        { 2143899649, 1338112849, 1562292083 },
        { 2143891457,   68149545,   87166451 },
        { 2143885313,  921750778,  394460854 },
        { 2143854593,  719766593,  133877196 },
        { 2143836161, 1149399850, 1861591875 },
        { 2143762433, 1848739366, 1335934145 },
        { 2143756289, 1326674710,  102999236 },
        { 2143713281,  808061791, 1156900308 },
        { 2143690753,  388399459, 1926468019 },
        { 2143670273, 1427891374, 1756689401 },
        { 2143666177, 1912173949,  986629565 },
        { 2143645697, 2041160111,  371842865 },
        { 2143641601, 1279906897, 2023974350 },
        { 2143635457,  720473174, 1389027526 },
        { 2143621121, 1298309455, 1732632006 },
        { 2143598593, 1548762216, 1825417506 },
        { 2143567873,  620475784, 1073787233 },
        { 2143561729, 1932954575,  949167309 },
        { 2143553537,  354315656, 1652037534 },
        { 2143541249,  577424288, 1097027618 },
        { 2143531009,  357862822,  478640055 },
        { 2143522817, 2017706025, 1550531668 },
        { 2143506433, 2078127419, 1824320165 },
        { 2143488001,  613475285, 1604011510 },
        { 2143469569, 1466594987,  502095196 },
        { 2143426561, 1115430331, 1044637111 },
        { 2143383553,    9778045, 1902463734 },
        { 2143377409, 1557401276, 2056861771 },
        { 2143363073,  652036455, 1965915971 },
        { 2143260673, 1464581171, 1523257541 },
        { 2143246337, 1876119649,  764541916 },
        { 2143209473, 1614992673, 1920672844 },
        { 2143203329,  981052047, 2049774209 },
        { 2143160321, 1847355533,  728535665 },
        { 2143129601,  965558457,  603052992 },
        { 2143123457, 2140817191,    8348679 },
        { 2143100929, 1547263683,  694209023 },
        { 2143092737,  643459066, 1979934533 },
        { 2143082497,  188603778, 2026175670 },
        { 2143062017, 1657329695,  377451099 },
        { 2143051777,  114967950,  979255473 },
        { 2143025153, 1698431342, 1449196896 },
        { 2143006721, 1862741675, 1739650365 },
        { 2142996481,  756660457,  996160050 },
        { 2142976001,  927864010, 1166847574 },
        { 2142965761,  905070557,  661974566 },
        { 2142916609,   40932754, 1787161127 },
        { 2142892033, 1987985648,  675335382 },
        { 2142885889,  797497211, 1323096997 },
        { 2142871553, 2068025830, 1411877159 },
        { 2142861313, 1217177090, 1438410687 },
        { 2142830593,  409906375, 1767860634 },
        { 2142803969, 1197788993,  359782919 },
        { 2142785537,  643817365,  513932862 },
        { 2142779393, 1717046338,  218943121 },
        { 2142724097,   89336830,  416687049 },
        { 2142707713,    5944581, 1356813523 },
        { 2142658561,  887942135, 2074011722 },
        { 2142638081,  151851972, 1647339939 },
        { 2142564353, 1691505537, 1483107336 },
        { 2142533633, 1989920200, 1135938817 },
        { 2142529537,  959263126, 1531961857 },
        { 2142527489,  453251129, 1725566162 },
        { 2142502913, 1536028102,  182053257 },
        { 2142498817,  570138730,  701443447 },
        { 2142416897,  326965800,  411931819 },
        { 2142363649, 1675665410, 1517191733 },
        { 2142351361,  968529566, 1575712703 },
        { 2142330881, 1384953238, 1769087884 },
        { 2142314497, 1977173242, 1833745524 },
        { 2142289921,   95082313, 1714775493 },
        { 2142283777,  109377615, 1070584533 },
        { 2142277633,   16960510,  702157145 },
        { 2142263297,  553850819,  431364395 },
        { 2142208001,  241466367, 2053967982 },
        { 2142164993, 1795661326, 1031836848 },
        { 2142097409, 1212530046,  712772031 },
        { 2142087169, 1763869720,  822276067 },
        { 2142078977,  644065713, 1765268066 },
        { 2142074881,  112671944,  643204925 },
        { 2142044161, 1387785471, 1297890174 },
        { 2142025729,  783885537, 1000425730 },
        { 2142011393,  905662232, 1679401033 },
        { 2141974529,  799788433,  468119557 },
        { 2141943809, 1932544124,  449305555 },
        { 2141933569, 1527403256,  841867925 },
        { 2141931521, 1247076451,  743823916 },
        { 2141902849, 1199660531,  401687910 },
        { 2141890561,  150132350, 1720336972 },
        { 2141857793, 1287438162,  663880489 },
        { 2141833217,  618017731, 1819208266 },
        { 2141820929,  999578638, 1403090096 },
        { 2141786113,   81834325, 1523542501 },
        { 2141771777,  120001928,  463556492 },
        { 2141759489,  122455485, 2124928282 },
        { 2141749249,  141986041,  940339153 },
        { 2141685761,  889088734,  477141499 },
        { 2141673473,  324212681, 1122558298 },
        { 2141669377, 1175806187, 1373818177 },
        { 2141655041, 1113654822,  296887082 },
        { 2141587457,  991103258, 1585913875 },
        { 2141583361, 1401451409, 1802457360 },
        { 2141575169, 1571977166,  712760980 },
        { 2141546497, 1107849376, 1250270109 },
        { 2141515777,  196544219,  356001130 },
        { 2141495297, 1733571506, 1060744866 },
        { 2141483009,  321552363, 1168297026 },
        { 2141458433,  505818251,  733225819 },
        { 2141360129, 1026840098,  948342276 },
        { 2141325313,  945133744, 2129965998 },
        { 2141317121, 1871100260, 1843844634 },
        { 2141286401, 1790639498, 1750465696 },
        { 2141267969, 1376858592,  186160720 },
        { 2141255681, 2129698296, 1876677959 },
        { 2141243393, 2138900688, 1340009628 },
        { 2141214721, 1933049835, 1087819477 },
        { 2141212673, 1898664939, 1786328049 },
        { 2141202433,  990234828,  940682169 },
        { 2141175809, 1406392421,  993089586 },
        { 2141165569, 1263518371,  289019479 },
        { 2141073409, 1485624211,  507864514 },
        { 2141052929, 1885134788,  311252465 },
        { 2141040641, 1285021247,  280941862 },
        { 2141028353, 1527610374,  375035110 },
        { 2141011969, 1400626168,  164696620 },
        { 2140999681,  632959608,  966175067 },
        { 2140997633, 2045628978, 1290889438 },
        { 2140993537, 1412755491,  375366253 },
        { 2140942337,  719477232,  785367828 },
        { 2140925953,   45224252,  836552317 },
        { 2140917761, 1157376588, 1001839569 },
        { 2140887041,  278480752, 2098732796 },
        { 2140837889, 1663139953,  924094810 },
        { 2140788737,  802501511, 2045368990 },
        { 2140766209, 1820083885, 1800295504 },
        { 2140764161, 1169561905, 2106792035 },
        { 2140696577,  127781498, 1885987531 },
        { 2140684289,   16014477, 1098116827 },
        { 2140653569,  665960598, 1796728247 },
        { 2140594177, 1043085491,  377310938 },
        { 2140579841, 1732838211, 1504505945 },
        { 2140569601,  302071939,  358291016 },
        { 2140567553,  192393733, 1909137143 },
        { 2140557313,  406595731, 1175330270 },
        { 2140549121, 1748850918,  525007007 },
        { 2140477441,  499436566, 1031159814 },
        { 2140469249, 1886004401, 1029951320 },
        { 2140426241, 1483168100, 1676273461 },
        { 2140420097, 1779917297,  846024476 },
        { 2140413953,  522948893, 1816354149 },
        { 2140383233, 1931364473, 1296921241 },
        { 2140366849, 1917356555,  147196204 },
        { 2140354561,   16466177, 1349052107 },
        { 2140348417, 1875366972, 1860485634 },
        { 2140323841,  456498717, 1790256483 },
        { 2140321793, 1629493973,  150031888 },
        { 2140315649, 1904063898,  395510935 },
        { 2140280833, 1784104328,  831417909 },
        { 2140250113,  256087139,  697349101 },
        { 2140229633,  388553070,  243875754 },
        { 2140223489,  747459608, 1396270850 },
        { 2140200961,  507423743, 1895572209 },
        { 2140162049,  580106016, 2045297469 },
        { 2140149761,  712426444,  785217995 },
        { 2140137473, 1441607584,  536866543 },
        { 2140119041,  346538902, 1740434653 },
        { 2140090369,  282642885,   21051094 },
        { 2140076033, 1407456228,  319910029 },
        { 2140047361, 1619330500, 1488632070 },
        { 2140041217, 2089408064, 2012026134 },
        { 2140008449, 1705524800, 1613440760 },
        { 2139924481, 1846208233, 1280649481 },
        { 2139906049,  989438755, 1185646076 },
        { 2139867137, 1522314850,  372783595 },
        { 2139842561, 1681587377,  216848235 },
        { 2139826177, 2066284988, 1784999464 },
        { 2139824129,  480888214, 1513323027 },
        { 2139789313,  847937200,  858192859 },
        { 2139783169, 1642000434, 1583261448 },
        { 2139770881,  940699589,  179702100 },
        { 2139768833,  315623242,  964612676 },
        { 2139666433,  331649203,  764666914 },
        { 2139641857, 2118730799, 1313764644 },
        { 2139635713,  519149027,  519212449 },
        { 2139598849, 1526413634, 1769667104 },
        { 2139574273,  551148610,  820739925 },
        { 2139568129, 1386800242,  472447405 },
        { 2139549697,  813760130, 1412328531 },
        { 2139537409, 1615286260, 1609362979 },
        { 2139475969, 1352559299, 1696720421 },
        { 2139455489, 1048691649, 1584935400 },
        { 2139432961,  836025845,  950121150 },
        { 2139424769, 1558281165, 1635486858 },
        { 2139406337, 1728402143, 1674423301 },
        { 2139396097, 1727715782, 1483470544 },
        { 2139383809, 1092853491, 1741699084 },
        { 2139369473,  690776899, 1242798709 },
        { 2139351041, 1768782380, 2120712049 },
        { 2139334657, 1739968247, 1427249225 },
        { 2139332609, 1547189119,  623011170 },
        { 2139310081, 1346827917, 1605466350 },
        { 2139303937,  369317948,  828392831 },
        { 2139301889, 1560417239, 1788073219 },
        { 2139283457, 1303121623,  595079358 },
        { 2139248641, 1354555286,  573424177 },
        { 2139240449,   60974056,  885781403 },
        { 2139222017,  355573421, 1221054839 },
        { 2139215873,  566477826, 1724006500 },
        { 2139150337,  871437673, 1609133294 },
        { 2139144193, 1478130914, 1137491905 },
        { 2139117569, 1854880922,  964728507 },
        { 2139076609,  202405335,  756508944 },
        { 2139062273, 1399715741,  884826059 },
        { 2139045889, 1051045798, 1202295476 },
        { 2139033601, 1707715206,  632234634 },
        { 2139006977, 2035853139,  231626690 },
        { 2138951681,  183867876,  838350879 },
        { 2138945537, 1403254661,  404460202 },
        { 2138920961,  310865011, 1282911681 },
        { 2138910721, 1328496553,  103472415 },
        { 2138904577,   78831681,  993513549 },
        { 2138902529, 1319697451, 1055904361 },
        { 2138816513,  384338872, 1706202469 },
        { 2138810369, 1084868275,  405677177 },
        { 2138787841,  401181788, 1964773901 },
        { 2138775553, 1850532988, 1247087473 },
        { 2138767361,  874261901, 1576073565 },
        { 2138757121, 1187474742,  993541415 },
        { 2138748929, 1782458888, 1043206483 },
        { 2138744833, 1221500487,  800141243 },
        { 2138738689,  413465368, 1450660558 },
        { 2138695681,  739045140,  342611472 },
        { 2138658817, 1355845756,  672674190 },
        { 2138644481,  608379162, 1538874380 },
        { 2138632193, 1444914034,  686911254 },
        { 2138607617,  484707818, 1435142134 },
        { 2138591233,  539460669, 1290458549 },
        { 2138572801, 2093538990, 2011138646 },
        { 2138552321, 1149786988, 1076414907 },
        { 2138546177,  840688206, 2108985273 },
        { 2138533889,  209669619,  198172413 },
        { 2138523649, 1975879426, 1277003968 },
        { 2138490881, 1351891144, 1976858109 },
        { 2138460161, 1817321013, 1979278293 },
        { 2138429441, 1950077177,  203441928 },
        { 2138400769,  908970113,  628395069 },
        { 2138398721,  219890864,  758486760 },
        { 2138376193, 1306654379,  977554090 },
        { 2138351617,  298822498, 2004708503 },
        { 2138337281,  441457816, 1049002108 },
        { 2138320897, 1517731724, 1442269609 },
        { 2138290177, 1355911197, 1647139103 },
        { 2138234881,  531313247, 1746591962 },
        { 2138214401, 1899410930,  781416444 },
        { 2138202113, 1813477173, 1622508515 },
        { 2138191873, 1086458299, 1025408615 },
        { 2138183681, 1998800427,  827063290 },
        { 2138173441, 1921308898,  749670117 },
        { 2138103809, 1620902804, 2126787647 },
        { 2138099713,  828647069, 1892961817 },
        { 2138085377,  179405355, 1525506535 },
        { 2138060801,  615683235, 1259580138 },
        { 2138044417, 2030277840, 1731266562 },
        { 2138042369, 2087222316, 1627902259 },
        { 2138032129,  126388712, 1108640984 },
        { 2138011649,  715026550, 1017980050 },
        { 2137993217, 1693714349, 1351778704 },
        { 2137888769, 1289762259, 1053090405 },
        { 2137853953,  199991890, 1254192789 },
        { 2137833473,  941421685,  896995556 },
        { 2137817089,  750416446, 1251031181 },
        { 2137792513,  798075119,  368077456 },
        { 2137786369,  878543495, 1035375025 },
        { 2137767937,    9351178, 1156563902 },
        { 2137755649, 1382297614, 1686559583 },
        { 2137724929, 1345472850, 1681096331 },
        { 2137704449,  834666929,  630551727 },
        { 2137673729, 1646165729, 1892091571 },
        { 2137620481,  778943821,   48456461 },
        { 2137618433, 1730837875, 1713336725 },
        { 2137581569,  805610339, 1378891359 },
        { 2137538561,  204342388, 1950165220 },
        { 2137526273, 1947629754, 1500789441 },
        { 2137516033,  719902645, 1499525372 },
        { 2137491457,  230451261,  556382829 },
        { 2137440257,  979573541,  412760291 },
        { 2137374721,  927841248, 1954137185 },
        { 2137362433, 1243778559,  861024672 },
        { 2137313281, 1341338501,  980638386 },
        { 2137311233,  937415182, 1793212117 },
        { 2137255937,  795331324, 1410253405 },
        { 2137243649,  150756339, 1966999887 },
        { 2137182209,  163346914, 1939301431 },
        { 2137171969, 1952552395,  758913141 },
        { 2137159681,  570788721,  218668666 },
        { 2137147393, 1896656810, 2045670345 },
        { 2137141249,  358493842,  518199643 },
        { 2137139201, 1505023029,  674695848 },
        { 2137133057,   27911103,  830956306 },
        { 2137122817,  439771337, 1555268614 },
        { 2137116673,  790988579, 1871449599 },
        { 2137110529,  432109234,  811805080 },
        { 2137102337, 1357900653, 1184997641 },
        { 2137098241,  515119035, 1715693095 },
        { 2137090049,  408575203, 2085660657 },
        { 2137085953, 2097793407, 1349626963 },
        { 2137055233, 1556739954, 1449960883 },
        { 2137030657, 1545758650, 1369303716 },
        { 2136987649,  332602570,  103875114 },
        { 2136969217, 1499989506, 1662964115 },
        { 2136924161,  857040753,    4738842 },
        { 2136895489, 1948872712,  570436091 },
        { 2136893441,   58969960, 1568349634 },
        { 2136887297, 2127193379,  273612548 },
        { 2136850433,  111208983, 1181257116 },
        { 2136809473, 1627275942, 1680317971 },
        { 2136764417, 1574888217,   14011331 },
        { 2136741889,   14011055, 1129154251 },
        { 2136727553,   35862563, 1838555253 },
        { 2136721409,  310235666, 1363928244 },
        { 2136698881, 1612429202, 1560383828 },
        { 2136649729, 1138540131,  800014364 },
        { 2136606721,  602323503, 1433096652 },
        { 2136563713,  182209265, 1919611038 },
        { 2136555521,  324156477,  165591039 },
        { 2136549377,  195513113,  217165345 },
        { 2136526849, 1050768046,  939647887 },
        { 2136508417, 1886286237, 1619926572 },
        { 2136477697,  609647664,   35065157 },
        { 2136471553,  679352216, 1452259468 },
        { 2136457217,  128630031,  824816521 },
        { 2136422401,   19787464, 1526049830 },
        { 2136420353,  698316836, 1530623527 },
        { 2136371201, 1651862373, 1804812805 },
        { 2136334337,  326596005,  336977082 },
        { 2136322049,   63253370, 1904972151 },
        { 2136297473,  312176076,  172182411 },
        { 2136248321,  381261841,  369032670 },
        { 2136242177,  358688773, 1640007994 },
        { 2136229889,  512677188,   75585225 },
        { 2136219649, 2095003250, 1970086149 },
        { 2136207361, 1909650722,  537760675 },
        { 2136176641, 1334616195, 1533487619 },
        { 2136158209, 2096285632, 1793285210 },
        { 2136143873, 1897347517,  293843959 },
        { 2136133633,  923586222, 1022655978 },
        { 2136096769, 1464868191, 1515074410 },
        { 2136094721, 2020679520, 2061636104 },
        { 2136076289,  290798503, 1814726809 },
        { 2136041473,  156415894, 1250757633 },
        { 2135996417,  297459940, 1132158924 },
        { 2135955457,  538755304, 1688831340 },
        { 0, 0, 0 }
};


DOUBLE gram_schmidt_norm(SINT32 *f, SINT32 *g, size_t n,
    SINT32 q, DOUBLE bd)
{
    // FIRST NORM
    // Don't bother creating the arrays with the correct signs,
    // the values are being squared so directly multiply-accumulate
    // the input f, g
    DOUBLE modx = 0;
    for (size_t i=n; i--;) {
        modx += f[i] * f[i] + g[i] * g[i];
    }
    modx = sqrt(modx);
#if DEBUG_GPV == 1
    fprintf(stderr, "||(g, -f)|| = %3.3f\n", modx);
#endif

    // Early termination - if ||(g,-f)|| cannot satisfy the condition
    // threshold then there's no point continuing, output the bad
    // Gram Schmidt norm and try again.
    if (modx > bd) {
        return modx;
    }


    size_t i;
#if 0
    // SECOND NORM
    // Floating-point precision is required
    DOUBLE *f2, *g2;
    f2 = SC_MALLOC(sizeof(DOUBLE) * 2 * n);
    g2 = f2 + n;
    sc_fft_t *ctx_fft = create_fft(n);
    SINT32 fb[n], gb[n];
    sc_complex_t f_fft[n], g_fft[n];
    sc_complex_t fb_fft[n], gb_fft[n];
    sc_complex_t F[n], G[n];

    fb[0] = f[0];
    for (i=1; i<n; i++) {
        fb[i] = -f[n-i];
    }
    gb[0] = g[0];
    for (i=1; i<n; i++) {
        gb[i] = -g[n-i];
    }

    fwd_fft_int(ctx_fft, f_fft, f);
    fwd_fft_int(ctx_fft, g_fft, g);
    fwd_fft_int(ctx_fft, fb_fft, fb);
    fwd_fft_int(ctx_fft, gb_fft, gb);

    for (i=0; i<n; i++) {
        sc_complex_t temp = f_fft[i]*fb_fft[i] + g_fft[i]*gb_fft[i];
        temp = 1 / temp;
        F[i] = fb_fft[i] * temp;
        G[i] = gb_fft[i] * temp;
    }
    inv_fft_dbl(ctx_fft, f2, F);
    inv_fft_dbl(ctx_fft, g2, G);
#else
    // SECOND NORM
    // Floating-point precision is required
    DOUBLE *f2, *g2;
    f2 = SC_MALLOC(sizeof(DOUBLE) * 2 * n);
    g2 = f2 + n;
    sc_fft_t *ctx_fft = create_fft(n);
    sc_complex_t *f_fft, *g_fft, *F, *G;
    f_fft = SC_MALLOC(sizeof(sc_complex_t) * 4 * n);
    g_fft = f_fft + n;
    F = g_fft + n;
    G = F + n;
    fwd_fft_int(ctx_fft, f_fft, f);
    fwd_fft_int(ctx_fft, g_fft, g);

    // This is an approximation
    for(i=0; i<n; i++) {
        sc_complex_t temp = f_fft[i]*f_fft[n-1-i] + g_fft[i]*g_fft[n-1-i];
        F[i] = f_fft[i] / temp;
        G[i] = g_fft[i] / temp;
    }

    inv_fft_dbl(ctx_fft, f2, F);
    inv_fft_dbl(ctx_fft, g2, G);
    SC_FREE(f_fft, sizeof(sc_complex_t) * 4 * n);
#endif

    destroy_fft(ctx_fft);

    DOUBLE b_N1 = 0;
    for(i=n; i--;) {
        b_N1 += f2[i] * f2[i] + g2[i] * g2[i];
    }
    b_N1 = (DOUBLE) q * sqrt(b_N1);

    SC_FREE(f2, sizeof(DOUBLE) * 2 * n);

    if (b_N1 < 0 || isnanl(b_N1)) {

        return 2*bd;
    }

#if DEBUG_GPV == 1
    fprintf(stderr, "||(qfb/(ggb + ffb), qgb/(ggb + ffb))|| = %3.9f\n", b_N1);
#endif
    if (modx > b_N1) {
        return modx;
    }
    else {
        return b_N1;
    }
}

static SINT32 poly_limb_anticirculant(const SINT32 *f, size_t n, SINT32 *mat_A)
{
    size_t i, j;

    SINT32 deg_f = poly_32_degree(f, n);
    if (-1 == deg_f || n <= (size_t)deg_f) {
        return SC_FUNC_FAILURE;
    }

    for (i=0; i<n; i++) {
        for (j=i; (j<=deg_f+i) && (j<n); j++) {
            mat_A[i*n+j] = f[j-i];
        }
        for (j=0; (j+n)<=(deg_f+i); j++) {
            mat_A[i*n+j] = -f[j-i+n];
        }
    }

    return SC_FUNC_SUCCESS;
}

SINT32 gpv_expand_basis(const gpv_t *gpv)
{
    size_t i, j;
    size_t n = gpv->n;
    SINT32 *mat_A = SC_MALLOC(sizeof(SINT32) * n * n);
    if (NULL == mat_A) {
        return SC_FUNC_FAILURE;
    }

    /// @todo Modify the anticirculant function to avoid intermediate storage
    /// and data copying

    if (SC_FUNC_FAILURE == poly_limb_anticirculant(gpv->g, n, mat_A)) {
        return SC_FUNC_FAILURE;
    }
    for (i=0; i<n; i++) {
        for (j=0; j<n; j++) {
            gpv->b[i*2*n+j] = mat_A[i*n+j];
        }
    }

    if (SC_FUNC_FAILURE == poly_limb_anticirculant(gpv->f, n, mat_A)) {
        return SC_FUNC_FAILURE;
    }
    for (i=0; i<n; i++) {
        for (j=0; j<n; j++) {
            gpv->b[i*2*n+j+n] = -mat_A[i*n+j];
        }
    }

    if (SC_FUNC_FAILURE == poly_limb_anticirculant(gpv->G, n, mat_A)) {
        return SC_FUNC_FAILURE;
    }
    for (i=0; i<n; i++) {
        for (j=0; j<n; j++) {
            gpv->b[(i+n)*2*n+j] = mat_A[i*n+j];
        }
    }

    if (SC_FUNC_FAILURE == poly_limb_anticirculant(gpv->F, n, mat_A)) {
        return SC_FUNC_FAILURE;
    }
    for (i=0; i<n; i++) {
        for (j=0; j<n; j++) {
            gpv->b[(i+n)*2*n+j+n] = -mat_A[i*n+j];
        }
    }

    SC_FREE(mat_A, sizeof(SINT32) * n * n);

    return SC_FUNC_SUCCESS;
}

SINT32 gpv_read_basis(const gpv_t *gpv, size_t row, size_t col)
{
    size_t n = gpv->n;
    SINT32 i = (SINT32)col - (SINT32)row;
    SINT32 p;
    size_t first = col < n;
    while (i < 0) i += n;
    while (i >= n) i -= n;
    p = (row < n)? (first)? gpv->g[i] : -gpv->f[i] :
                   (first)? gpv->G[i] : -gpv->F[i];
    if (col >= n) col -= n;
    if (row >= n) row -= n;
    return (col < row)? -p : p;
}

FLOAT dot(const SINT32 *x, const SINT32 *y, size_t n, size_t u, size_t v)                            //dot product of two vectors within 2D arrays----columns u and v, size=length of vectors
{
    size_t k;
    FLOAT dot = 0;

    for (k=0; k<n; k++) {
        dot += x[u*n + k] * y[v*n + k];
    }

    return dot;
}

FLOAT dot_flt(const FLOAT *x, const FLOAT *y, size_t n, size_t u, size_t v)                            //dot product of two vectors within 2D arrays----columns u and v, size=length of vectors
{
    size_t k;
    FLOAT dot = 0;

    for (k=0; k<n; k++) {
        dot += x[u*n + k] * y[v*n + k];
    }

    return dot;
}

DOUBLE dot_s32_dbl(const SINT32 * SC_RESTRICT x, const DOUBLE * SC_RESTRICT y, size_t n, size_t u, size_t v)                            //dot product of two vectors within 2D arrays----columns u and v, size=length of vectors
{
    size_t k;
    DOUBLE dot = 0;
    const SINT32 *a = x + u*n;
    const DOUBLE *b = y + v*n;

    for (k=n; k--;) {
        dot += *a++ * *b++;
    }

    return dot;
}

DOUBLE dot_s64_dbl(const SINT64 * SC_RESTRICT x, const DOUBLE * SC_RESTRICT y, size_t n, size_t u, size_t v)                            //dot product of two vectors within 2D arrays----columns u and v, size=length of vectors
{
    size_t k;
    DOUBLE dot = 0;
    const SINT64 *a = x + u*n;
    const DOUBLE *b = y + v*n;

    for (k=n; k--;) {
        dot += *a++ * *b++;
    }

    return dot;
}

FLOAT dot_s32_flt(const SINT32 * SC_RESTRICT x, const FLOAT * SC_RESTRICT y, size_t n, size_t u, size_t v)                            //dot product of two vectors within 2D arrays----columns u and v, size=length of vectors
{
    size_t k;
    FLOAT dot = 0;
    const SINT32 *a = x + u*n;
    const FLOAT *b = y + v*n;

    for (k=n; k--;) {
        dot += *a++ * *b++;
    }

    return dot;
}

FLOAT dot_s64_flt(const SINT64 * SC_RESTRICT x, const FLOAT * SC_RESTRICT y, size_t n, size_t u, size_t v)                            //dot product of two vectors within 2D arrays----columns u and v, size=length of vectors
{
    size_t k;
    FLOAT dot = 0;
    const SINT64 *a = x + u*n;
    const FLOAT *b = y + v*n;

    for (k=n; k--;) {
        dot += (FLOAT)(*a++) * *b++;
    }

    return dot;
}

DOUBLE dot_dbl(const DOUBLE * SC_RESTRICT x, const DOUBLE * SC_RESTRICT y, size_t n, size_t u, size_t v)                            //dot product of two vectors within 2D arrays----columns u and v, size=length of vectors
{
    size_t k;
    DOUBLE dot = 0;
    const DOUBLE *a = x + u*n;
    const DOUBLE *b = y + v*n;

    for (k=n; k--;) {
        dot += *a++ * *b++;
    }

    return dot;
}

DOUBLE dot_sqr_dbl(const DOUBLE *x, size_t n, size_t u, size_t v)                            //dot product of two vectors within 2D arrays----columns u and v, size=length of vectors
{
    size_t k;
    DOUBLE dot = 0;
    const DOUBLE *a = x + u*n;

    for (k=n; k--;) {
        dot += (*a) * (*a);
        a++;
    }

    return dot;
}

FLOAT dot_sqr_flt(const FLOAT *x, size_t n, size_t u, size_t v)                            //dot product of two vectors within 2D arrays----columns u and v, size=length of vectors
{
    size_t k;
    FLOAT dot = 0;
    const FLOAT *a = x + u*n;

    for (k=n; k--;) {
        dot += (*a) * (*a);
        a++;
    }

    return dot;
}

LONGDOUBLE dot_ldbl(const LONGDOUBLE *x, const LONGDOUBLE *y, size_t n, size_t u, size_t v)
{
    size_t k;
    LONGDOUBLE dot = 0.0L;

    for (k=0; k<n; k++) {
        dot += x[u*n + k] * y[v*n + k];
    }

    return dot;
}

DOUBLE dot_ldbl_dbl(const LONGDOUBLE *x, const DOUBLE *y, size_t n, size_t u, size_t v)
{
    size_t k;
    DOUBLE dot = 0;

    for (k=0; k<n; k++) {
        dot += (DOUBLE) x[u*n + k] * y[v*n + k];
    }

    return dot;
}

FLOAT dot_ldbl_flt(const LONGDOUBLE *x, const FLOAT *y, size_t n, size_t u, size_t v)
{
    size_t k;
    FLOAT dot = 0;

    for (k=0; k<n; k++) {
        dot += (FLOAT) x[u*n + k] * y[v*n + k];
    }

    return dot;
}

LONGDOUBLE dot_s32_ldbl(const SINT32 *x, const LONGDOUBLE *y, size_t n, size_t u, size_t v)
{
    size_t k;
    LONGDOUBLE dot = 0;

    for (k=0; k<n; k++) {
        dot += (LONGDOUBLE) x[u*n + k] * y[v*n + k];
    }

    return dot;
}

LONGDOUBLE dot_s64_ldbl(const SINT64 *x, const LONGDOUBLE *y, size_t n, size_t u, size_t v)
{
    size_t k;
    LONGDOUBLE dot = 0;

    for (k=0; k<n; k++) {
        dot += (LONGDOUBLE) x[u*n + k] * y[v*n + k];
    }

    return dot;
}

void gpv_precompute_inv_ldbl(const LONGDOUBLE *b_gs, LONGDOUBLE *b_gs_inv_norm, size_t n)
{
    size_t j;
    for (j=0; j<n; j++) {
        LONGDOUBLE sqr = dot_ldbl(b_gs, b_gs, n, j, j);
        b_gs_inv_norm[j] = 1.0 / sqrtl(sqr);
    }
}

void gpv_precompute_inv_dbl(const DOUBLE *b_gs, DOUBLE *b_gs_inv_norm, size_t n)
{
    size_t j;
    for (j=0; j<n; j++) {
        DOUBLE sqr = dot_dbl(b_gs, b_gs, n, j, j);
        b_gs_inv_norm[j] = 1.0 / sqrt(sqr);
    }
}

void gpv_precompute_inv_flt(const FLOAT *b_gs, FLOAT *b_gs_inv_norm, size_t n)
{
    size_t j;
    for (j=0; j<n; j++) {
        DOUBLE sqr = dot_flt(b_gs, b_gs, n, j, j);
        b_gs_inv_norm[j] = (FLOAT)(1.0 / sqrt(sqr));
    }
}

void modified_gram_schmidt_classical(const gpv_t *gpv, LONGDOUBLE *b_gs, SINT32 q)
{
    size_t i, j, k;
    size_t n = gpv->n;
    LONGDOUBLE inv_sq_norm[2*n], temp[2*n];

    inv_sq_norm[0] = 0;
    for (k=0; k<2*n; k++) {
        inv_sq_norm[0] += gpv->b[k] * gpv->b[k];
    }
    inv_sq_norm[0] = 1 / inv_sq_norm[0];

    for (j=0; j<2*n; j++) {
        b_gs[j] = gpv->b[j];
    }

    for (i=1; i<2*n; i++) {
        for (k=0; k<2*n; k++) {
            b_gs[i*2*n + k] = gpv->b[i*2*n + k];
        }

        for (j=0; j<i; j++) {
            temp[j] = dot_ldbl(b_gs, b_gs, 2*n, i, j) * inv_sq_norm[j];
        }

        for (k=0; k<2*n; k++) {
            for (j=0; j<i; j++) {
                b_gs[i*2*n + k] -= temp[j] * gpv->b[j*2*n + k];
            }
        }

        inv_sq_norm[i] = 1 / dot_ldbl(b_gs, b_gs, 2*n, i, i);
    }
}

void modified_gram_schmidt_fast_flt(const gpv_t *gpv,
    FLOAT *b_gs, SINT32 q)
{
    size_t i, j;
    size_t n = gpv->n;
    FLOAT v[2*n] SC_DEFAULT_ALIGNED, v1[2*n] SC_DEFAULT_ALIGNED;
    FLOAT C_k, D_k, D_k_inv;

    // First half

    for (i=0; i<n; i++) {
        b_gs[i] = gpv->g[i];
        b_gs[n+i] = -gpv->f[i];
    }

    for (i=0; i<n-1; i++) {
        v[i] = b_gs[i+1];
        v[n+i] = b_gs[i+n+1];
    }
    v[n-1] = -b_gs[0];
    v[2*n-1] = -b_gs[n];

    for (i=0; i<2*n; i++) {
        v1[i] = v[i];
    }

    C_k = dot_flt(b_gs, v, 2*n, 0, 0);
    D_k = dot_sqr_flt(v, 2*n, 0, 0);

    for (i=1; i<n; i++) {
        FLOAT aux = C_k / D_k;
        b_gs[i*2*n]     = -b_gs[(i-1)*2*n + n - 1]   + aux*v[n-1];
        b_gs[i*2*n + n] = -b_gs[(i-1)*2*n + 2*n - 1] + aux*v[2*n-1];
        for (j=1; j<n; j++) {
            b_gs[i*2*n + j]     = b_gs[(i-1)*2*n + j - 1]     - aux*v[j-1];
            b_gs[i*2*n + n + j] = b_gs[(i-1)*2*n + n + j - 1] - aux*v[n+j-1];
        }

        for (j=0; j<2*n; j++) {
            v[j] -= aux * b_gs[(i-1)*2*n + j];
        }

        FLOAT C_ko = C_k;
        FLOAT D_ko = D_k;
        C_k = dot_flt(b_gs, v1, 2*n, i, 0);
        D_k = D_ko - C_ko * C_ko / D_ko;
    }

    // Second half

    D_k_inv = 1 / D_k;
    for (i=0; i<n; i++) {
        b_gs[n*2*n + n + i] = b_gs[(n-1)*2*n + n - 1 - i] * (FLOAT)q * D_k_inv;
        b_gs[n*2*n + i]     = -b_gs[(n-1)*2*n + 2*n - 1 - i] * (FLOAT)q * D_k_inv;
    }

    for (i=0; i<n-1; i++) {
        v[i]   = b_gs[n*2*n+i+1];
        v[n+i] = b_gs[n*2*n+i+n+1];
    }
    v[n-1] = -b_gs[n*2*n];
    v[2*n-1] = -b_gs[n*2*n + n];

    for (i=0; i<2*n; i++) {
        v1[i] = v[i];
    }

    C_k = dot_flt(b_gs, v1, 2*n, n, 0);
    D_k = dot_sqr_flt(b_gs, 2*n, n, n);

    for (i=n+1; i<2*n; i++) {
        FLOAT aux = C_k / D_k;
        b_gs[i*2*n]     = -b_gs[(i-1)*2*n + n - 1]   + aux*v[n-1];
        b_gs[i*2*n + n] = -b_gs[(i-1)*2*n + 2*n - 1] + aux*v[2*n-1];
        for (j=1; j<n; j++) {
            b_gs[i*2*n + j]     = b_gs[(i-1)*2*n + j - 1]     - aux*v[j-1];
            b_gs[i*2*n + n + j] = b_gs[(i-1)*2*n + n + j - 1] - aux*v[n+j-1];
        }

        for (j=0; j<2*n; j++) {
            v[j] -= aux * b_gs[(i-1)*2*n + j];
        }

        FLOAT C_ko = C_k;
        FLOAT D_ko = D_k;
        C_k = dot_flt(b_gs, v1, 2*n, i, 0);
        D_k = D_ko - C_ko * C_ko / D_ko;
    }
}

void modified_gram_schmidt_fast_dbl(const gpv_t *gpv,
    DOUBLE *b_gs, SINT32 q)
{
    size_t i, j;
    size_t n = gpv->n;
    DOUBLE v[2*n] SC_DEFAULT_ALIGNED, v1[2*n] SC_DEFAULT_ALIGNED;
    DOUBLE C_k, D_k;

    // First half

    for (i=0; i<n; i++) {
        b_gs[i] = gpv->g[i];
        b_gs[n+i] = -gpv->f[i];
    }

    for (i=0; i<n-1; i++) {
        v[i] = b_gs[i+1];
        v[n+i] = b_gs[i+n+1];
    }
    v[n-1] = -b_gs[0];
    v[2*n-1] = -b_gs[n];

    for (i=0; i<2*n; i++) {
        v1[i] = v[i];
    }

    C_k = dot_dbl(b_gs, v, 2*n, 0, 0);
    D_k = dot_sqr_dbl(v, 2*n, 0, 0);

    for (i=1; i<n; i++) {
        DOUBLE aux = C_k / D_k;
        b_gs[i*2*n]     = -b_gs[(i-1)*2*n + n - 1]   + aux*v[n-1];
        b_gs[i*2*n + n] = -b_gs[(i-1)*2*n + 2*n - 1] + aux*v[2*n-1];
        for (j=1; j<n; j++) {
            b_gs[i*2*n + j]     = b_gs[(i-1)*2*n + j - 1]     - aux*v[j-1];
            b_gs[i*2*n + n + j] = b_gs[(i-1)*2*n + n + j - 1] - aux*v[n+j-1];
        }

        for (j=0; j<2*n; j++) {
            v[j] -= aux * b_gs[(i-1)*2*n + j];
        }

        DOUBLE C_ko = C_k;
        DOUBLE D_ko = D_k;
        C_k = dot_dbl(b_gs, v1, 2*n, i, 0);
        D_k = D_ko - C_ko * C_ko / D_ko;
    }

    // Second half

    DOUBLE inv_D_k = 1.0 / D_k;
    for (i=0; i<n; i++) {
        b_gs[n*2*n + n + i] = b_gs[(n-1)*2*n + n - 1 - i] * (DOUBLE)q * inv_D_k;
        b_gs[n*2*n + i]     = -b_gs[(n-1)*2*n + 2*n - 1 - i] * (DOUBLE)q * inv_D_k;
    }

    for (i=0; i<n-1; i++) {
        v[i]   = b_gs[n*2*n+i+1];
        v[n+i] = b_gs[n*2*n+i+n+1];
    }
    v[n-1] = -b_gs[n*2*n];
    v[2*n-1] = -b_gs[n*2*n + n];

    for (i=0; i<2*n; i++) {
        v1[i] = v[i];
    }

    C_k = dot_dbl(b_gs, v1, 2*n, n, 0);
    D_k = dot_sqr_dbl(b_gs, 2*n, n, n);

    for (i=n+1; i<2*n; i++) {
        DOUBLE aux = C_k / D_k;
        b_gs[i*2*n]     = -b_gs[(i-1)*2*n + n - 1]   + aux*v[n-1];
        b_gs[i*2*n + n] = -b_gs[(i-1)*2*n + 2*n - 1] + aux*v[2*n-1];
        for (j=1; j<n; j++) {
            b_gs[i*2*n + j]     = b_gs[(i-1)*2*n + j - 1]     - aux*v[j-1];
            b_gs[i*2*n + n + j] = b_gs[(i-1)*2*n + n + j - 1] - aux*v[n+j-1];
        }

        for (j=0; j<2*n; j++) {
            v[j] -= aux * b_gs[(i-1)*2*n + j];
        }

        DOUBLE C_ko = C_k;
        DOUBLE D_ko = D_k;
        C_k = dot_dbl(b_gs, v1, 2*n, i, 0);
        D_k = D_ko - C_ko * C_ko / D_ko;
    }
}

void modified_gram_schmidt_fast_ldbl(const gpv_t *gpv,
    LONGDOUBLE *b_gs, SINT32 q)
{
    size_t i, j;
    size_t n = gpv->n;
    LONGDOUBLE v[2*n] SC_DEFAULT_ALIGNED, v1[2*n] SC_DEFAULT_ALIGNED;
    LONGDOUBLE C_k, D_k;

    // First half

    for (i=0; i<n; i++) {
        b_gs[i] = gpv->g[i];
        b_gs[n+i] = -gpv->f[i];
    }

    for (i=0; i<n-1; i++) {
        v[i] = b_gs[i+1];
        v[n+i] = b_gs[i+n+1];
    }
    v[n-1] = -b_gs[0];
    v[2*n-1] = -b_gs[n];

    for (i=0; i<2*n; i++) {
        v1[i] = v[i];
    }

    C_k = dot_ldbl(b_gs, v, 2*n, 0, 0);
    D_k = dot_ldbl(v, v, 2*n, 0, 0);

    for (i=1; i<n; i++) {
        LONGDOUBLE aux = C_k / D_k;
        b_gs[i*2*n]     = -b_gs[(i-1)*2*n + n - 1]   + aux*v[n-1];
        b_gs[i*2*n + n] = -b_gs[(i-1)*2*n + 2*n - 1] + aux*v[2*n-1];
        for (j=1; j<n; j++) {
            b_gs[i*2*n + j]     = b_gs[(i-1)*2*n + j - 1]     - aux*v[j-1];
            b_gs[i*2*n + n + j] = b_gs[(i-1)*2*n + n + j - 1] - aux*v[n+j-1];
        }

        for (j=0; j<2*n; j++) {
            v[j] -= aux * b_gs[(i-1)*2*n + j];
        }

        LONGDOUBLE C_ko = C_k;
        LONGDOUBLE D_ko = D_k;
        C_k = dot_ldbl(b_gs, v1, 2*n, i, 0);
        D_k = D_ko - C_ko * C_ko / D_ko;
    }

    // Second half

    LONGDOUBLE D_k_inv = 1 / D_k;
    for (i=0; i<n; i++) {
        b_gs[n*2*n + n + i] = b_gs[(n-1)*2*n + n - 1 - i] * (LONGDOUBLE)q * D_k_inv;
        b_gs[n*2*n + i]     = -b_gs[(n-1)*2*n + 2*n - 1 - i] * (LONGDOUBLE)q * D_k_inv;
    }

    for (i=0; i<n-1; i++) {
        v[i]   = b_gs[n*2*n+i+1];
        v[n+i] = b_gs[n*2*n+i+n+1];
    }
    v[n-1] = -b_gs[n*2*n];
    v[2*n-1] = -b_gs[n*2*n + n];

    for (i=0; i<2*n; i++) {
        v1[i] = v[i];
    }

    C_k = dot_ldbl(b_gs, v1, 2*n, n, 0);
    D_k = dot_ldbl(b_gs, b_gs, 2*n, n, n);

    for (i=n+1; i<2*n; i++) {
        LONGDOUBLE aux = C_k / D_k;
        b_gs[i*2*n]     = -b_gs[(i-1)*2*n + n - 1]   + aux*v[n-1];
        b_gs[i*2*n + n] = -b_gs[(i-1)*2*n + 2*n - 1] + aux*v[2*n-1];
        for (j=1; j<n; j++) {
            b_gs[i*2*n + j]     = b_gs[(i-1)*2*n + j - 1]     - aux*v[j-1];
            b_gs[i*2*n + n + j] = b_gs[(i-1)*2*n + n + j - 1] - aux*v[n+j-1];
        }

        for (j=0; j<2*n; j++) {
            v[j] -= aux * b_gs[(i-1)*2*n + j];
        }

        LONGDOUBLE C_ko = C_k;
        LONGDOUBLE D_ko = D_k;
        C_k = dot_ldbl(b_gs, v1, 2*n, i, 0);
        D_k = D_ko - C_ko * C_ko / D_ko;
    }
}

static SINT32 verify_private_key_32(safecrypto_t *sc, const SINT32 *f, const SINT32 *g,
    const SINT32 *F, const SINT32 *G, UINT32 q, size_t n,
    const SINT32 *ntt_w, const SINT32 *ntt_r, const ntt_params_t *ntt_params)
{
    // Verify that the NTRU equation is solved, i.e. f*G - g*F = q

    size_t i;
    safecrypto_ntt_e ntt_type = SC_NTT_FLOATING_POINT;
    const utils_arith_ntt_t *sc_ntt = utils_arith_ntt(ntt_type);
    const utils_arith_poly_t *sc_poly  = sc->sc_poly;
    SINT32 *fn, *gn, *Fn, *Gn, *temp;
    UINT32 verify;
    SINT32 retval = SC_FUNC_FAILURE;

    temp = SC_MALLOC(sizeof(SINT32) * n * 3);
    fn = temp;
    gn = temp + n;
    Fn = temp + 2*n;
    Gn = temp + 2*n;

    // Calculate fG
    sc_ntt->fwd_ntt_32_32(fn, ntt_params, f, ntt_w);
    sc_ntt->fwd_ntt_32_32(Gn, ntt_params, G, ntt_w);
    sc_ntt->mul_32_pointwise(fn, ntt_params, fn, Gn);

    // Calculate gF
    sc_ntt->fwd_ntt_32_32(gn, ntt_params, g, ntt_w);
    sc_ntt->fwd_ntt_32_32(Fn, ntt_params, F, ntt_w);
    sc_ntt->mul_32_pointwise(gn, ntt_params, gn, Fn);

    // Calculate fG - gF
    sc_poly->sub_32(gn, n, fn, gn);
    sc_ntt->normalize_32(gn, n, ntt_params);

    // Verify that fG - gF = q = 0 mod q
    for (i=0; i<n; i++) {
        if (0 != gn[i]) {
            goto finish;
        }
    }

    retval = SC_FUNC_SUCCESS;

finish:
    SC_FREE(temp, sizeof(SINT32) * n * 3);
    return retval;
}

static SINT32 verify_private_key_16(safecrypto_t *sc, const SINT32 *f, const SINT32 *g,
    const SINT32 *F, const SINT32 *G, UINT32 q, size_t n,
    const SINT16 *ntt_w, const SINT16 *ntt_r, const ntt_params_t *ntt_params)
{
    // Verify that the NTRU equation is solved, i.e. f*G - g*F = q

    size_t i;
    safecrypto_ntt_e ntt_type = SC_NTT_FLOATING_POINT;
    const utils_arith_ntt_t *sc_ntt = utils_arith_ntt(ntt_type);
    const utils_arith_poly_t *sc_poly  = sc->sc_poly;
    SINT32 *fn, *gn, *Fn, *Gn, *temp;
    UINT32 verify;
    SINT32 retval = SC_FUNC_FAILURE;

    temp = SC_MALLOC(sizeof(SINT32) * n * 3);
    fn = temp;
    gn = temp + n;
    Fn = temp + 2*n;
    Gn = temp + 2*n;

    // Calculate fG
    sc_ntt->fwd_ntt_32_16(fn, ntt_params, f, ntt_w);
    sc_ntt->fwd_ntt_32_16(Gn, ntt_params, G, ntt_w);
    sc_ntt->mul_32_pointwise(fn, ntt_params, fn, Gn);

    // Calculate gF
    sc_ntt->fwd_ntt_32_16(gn, ntt_params, g, ntt_w);
    sc_ntt->fwd_ntt_32_16(Fn, ntt_params, F, ntt_w);
    sc_ntt->mul_32_pointwise(gn, ntt_params, gn, Fn);

    // Calculate fG - gF
    sc_poly->sub_32(gn, n, fn, gn);
    sc_ntt->normalize_32(gn, n, ntt_params);

    // Verify that fG - gF = q = 0 mod q
    for (i=0; i<n; i++) {
        if (0 != gn[i]) {
            goto finish;
        }
    }

    retval = SC_FUNC_SUCCESS;

finish:
    SC_FREE(temp, sizeof(SINT32) * n * 3);
    return retval;
}

SINT32 create_public_key(SINT32 *h, const SINT32 *f, const SINT32 *g,
    UINT32 q, size_t n, SINT32 ternary)
{
    safecrypto_ntt_e ntt_type = SC_NTT_FLOATING_POINT;
    const utils_arith_ntt_t *sc_ntt = utils_arith_ntt(ntt_type);
    SINT16 ntt_w[n];
    SINT16 ntt_r[n];
    SINT32 temp[n];

    // Dynamically allocate memory for the necessary NTT tables
    roots_of_unity_s16(ntt_w, ntt_r, n, q, 0, ternary);

    ntt_params_t ntt_q;
    init_reduce(&ntt_q, n, q);

    // Obtain NTT(f) and NTT(g)
    sc_ntt->fwd_ntt_32_16(h, &ntt_q, f, ntt_w);
    sc_ntt->fwd_ntt_32_16(temp, &ntt_q, g, ntt_w);

    // Attempt to invert NTT(f)
    if (SC_FUNC_FAILURE == sc_ntt->invert_32(h, &ntt_q, n)) {
        return SC_FUNC_FAILURE;
    }

    // h = g/f and f is invertible, so calculate public key
    sc_ntt->mul_32_pointwise(h, &ntt_q, temp, h);
    sc_ntt->inv_ntt_32_16(h, &ntt_q, h, ntt_w, ntt_r);
    sc_ntt->normalize_32(h, n, &ntt_q);

#if DEBUG_GPV == 1
    size_t i;
    fprintf(stderr, "\nh = g/f mod q =\n");
    for (i=0; i<n; i++) {
        fprintf(stderr, "%6d ", h[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
#endif

    return SC_FUNC_SUCCESS;
}

SINT32 create_public_key_32(SINT32 *h, const SINT32 *f, const SINT32 *g,
    UINT32 q, size_t n, SINT32 ternary)
{
    safecrypto_ntt_e ntt_type = SC_NTT_FLOATING_POINT;
    const utils_arith_ntt_t *sc_ntt = utils_arith_ntt(ntt_type);
    SINT32 ntt_w[n];
    SINT32 ntt_r[n];
    SINT32 temp[n];

    // Dynamically allocate memory for the necessary NTT tables
    roots_of_unity_s32(ntt_w, ntt_r, n, q, 0, ternary);

    ntt_params_t ntt_q;
    init_reduce(&ntt_q, n, q);

    // Obtain NTT(f) and NTT(g)
    sc_ntt->fwd_ntt_32_32(h, &ntt_q, f, ntt_w);
    sc_ntt->fwd_ntt_32_32(temp, &ntt_q, g, ntt_w);

    // Attempt to invert NTT(f)
    if (SC_FUNC_FAILURE == sc_ntt->invert_32(h, &ntt_q, n)) {
        return SC_FUNC_FAILURE;
    }

    // h = g/f and f is invertible, so calculate public key
    sc_ntt->mul_32_pointwise(h, &ntt_q, temp, h);
    sc_ntt->inv_ntt_32_32(h, &ntt_q, h, ntt_w, ntt_r);
    sc_ntt->normalize_32(h, n, &ntt_q);

#if DEBUG_GPV == 1
    size_t i;
    fprintf(stderr, "\nh = g/f mod q =\n");
    for (i=0; i<n; i++) {
        fprintf(stderr, "%6d ", h[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
#endif

    return SC_FUNC_SUCCESS;
}

static SINT32 gpv_gen_basis_original(safecrypto_t *sc, SINT32 *f, SINT32 *g, SINT32 *h,
    size_t n, SINT32 q,
    utils_sampling_t *sampling, prng_ctx_t *prng_ctx,
    SINT32 *F, SINT32 *G, SINT32 recreate_flag)
{
    size_t i, j;
    DOUBLE sigma;
    DOUBLE gs_norm;
    SINT32 retval = -1, num_retries = 0;
    sc_mpz_t Rf, Rg, gcd1, gcd2;
    sc_poly_mpz_t rho_f, rho_g, rho_dummy;
    sc_mpz_t alpha, beta, mp_q;
    sc_poly_mpz_t mp_f, mp_g;
    sc_mpz_t qv, qu;
    sc_poly_mpz_t pF, pG;
    sc_poly_mpz_t polymod;
    sc_poly_mpz_t pfbar, pgbar;
    sc_poly_mpz_t temp, num, den, k;
    sc_poly_mpz_t inv_f;
    sc_mpz_t scale;

    SC_TIMER_INSTANCE(timer);
    SC_TIMER_CREATE(timer);
    SC_TIMER_RESET(timer);

    SC_TIMER_INSTANCE(total_timer);
    SC_TIMER_CREATE(total_timer);
    SC_TIMER_RESET(total_timer);

    sc_mpz_init(&Rf);
    sc_mpz_init(&Rg);
    sc_mpz_init(&gcd1);
    sc_mpz_init(&gcd2);
    sc_poly_mpz_init(&rho_f, n+1);
    sc_poly_mpz_init(&rho_g, n+1);
    sc_poly_mpz_init(&rho_dummy, n+1);
    sc_mpz_init(&alpha);
    sc_mpz_init(&beta);
    sc_poly_mpz_init(&mp_f, n);
    sc_poly_mpz_init(&mp_g, n);
    sc_mpz_init(&mp_q);
    sc_mpz_set_ui(&mp_q, q);

    // Computations are done mod x^N+1-----this defines this polynomial
    sc_poly_mpz_init(&polymod, n+1);
    sc_poly_mpz_set_si(&polymod, 0, 1);
    sc_poly_mpz_set_si(&polymod, n, 1);

    sc_poly_mpz_init(&pF, n);
    sc_poly_mpz_init(&pG, n);
    sc_mpz_init(&qv);
    sc_mpz_init(&qu);

    sc_poly_mpz_init(&pfbar, n);
    sc_poly_mpz_init(&pgbar, n);

    sc_poly_mpz_init(&temp, 2*n);
    sc_poly_mpz_init(&num, n);
    sc_poly_mpz_init(&den, n);
    sc_poly_mpz_init(&k, n);

    sc_poly_mpz_init(&inv_f, n);

    sc_mpz_init(&scale);

    SC_TIMER_START(timer);
    SC_TIMER_START(total_timer);

    // Step 1. set standard deviation of Gaussian distribution
    DOUBLE bd;
    bd  = 1.17*sqrt(q);

    // Step 2. Obtain f, g using Gaussian Samplers
    sigma  = 1.17 * sqrt(q / (2*n));
#if DEBUG_GPV == 1
    fprintf(stderr, "n=%zu, q=%d\n", n, q);
#endif
step2:
    // If f and g are already provided as inputs as we are recreating F and G
    // then do not sample new distributions
    if (0 == recreate_flag) {
        get_vector_32(sampling, f, n, 0);
        get_vector_32(sampling, g, n, 0);
    }
    else {
        // If we are recreating the private key and we require a restart then
        // there has been an error
        goto finish;
    }

    // Step 3. calculate the GramSchmidt norm
    gs_norm = gram_schmidt_norm(f, g, n, q, bd);
    if (isnanl(gs_norm)) {
        num_retries++;
        goto step2;
    }

    // Step 4. check whether norm is small enough; if not, repeat
    if (gs_norm > bd) {
        num_retries++;
        goto step2;
    }
#if DEBUG_GPV == 1
    fprintf(stderr, "GS=%3.3f, threshold=%3.3f\n", gs_norm, bd);
#endif

    SC_TIMER_STOP(timer);
#if DEBUG_GPV == 1
    fprintf(stderr, "Time to compute GS Norm: %3.3f sec\n", SC_TIMER_GET_ELAPSED(timer));
#endif
    SC_TIMER_RESET(timer);
    SC_TIMER_START(timer);


    ntt_params_t *ntt_params = (SC_SCHEME_SIG_FALCON == sc->scheme)? &sc->falcon->ntt  :
                               (SC_SCHEME_IBE_DLP    == sc->scheme)? &sc->dlp_ibe->ntt :
                                                                     &sc->ens_dlp_sig->ntt;
    const SINT16 *ntt_w_16 = (SC_SCHEME_SIG_FALCON == sc->scheme)? sc->falcon->params->w  :
                             (SC_SCHEME_IBE_DLP    == sc->scheme)? 0 :
                                                                   sc->ens_dlp_sig->params->w;
    const SINT16 *ntt_r_16 = (SC_SCHEME_SIG_FALCON == sc->scheme)? sc->falcon->params->r  :
                             (SC_SCHEME_IBE_DLP    == sc->scheme)? 0 :
                                                                   sc->ens_dlp_sig->params->r;
    const SINT32 *ntt_w_32 = (SC_SCHEME_IBE_DLP == sc->scheme)? sc->dlp_ibe->params->w : 0;
    const SINT32 *ntt_r_32 = (SC_SCHEME_IBE_DLP == sc->scheme)? sc->dlp_ibe->params->r : 0;

    poly_si32_to_mpi(&mp_f, n, f);
    poly_si32_to_mpi(&mp_g, n, g);

    // Step 5, 6, 7. Polynomial Euclidean to find 4 unknowns
    //poly_mpi_reset(&rho_f, 0);
    sc_poly_mpz_xgcd(&mp_f, &polymod, &Rf, &rho_f, &rho_dummy);
    sc_mpz_gcd(&Rf, &mp_q, &gcd2);

#if DEBUG_GPV == 1
    fprintf(stderr, "GCD(Rf,q) = "); sc_mpz_out_str(stderr, 16, &gcd2); fprintf(stderr, "\n");
#endif

    SC_TIMER_STOP(timer);
#if DEBUG_GPV == 1
    fprintf(stderr, "Time to compute XGCD(f,phi): %3.3f sec\n", SC_TIMER_GET_ELAPSED(timer));
#endif
    SC_TIMER_RESET(timer);
    SC_TIMER_START(timer);

    if (0 != sc_mpz_cmp_ui(&gcd2, 1)) {
        // It is more efficient to check that gcd(Rf,q) == 1 early
        num_retries++;
        goto step2;
    }
    sc_poly_mpz_xgcd(&mp_g, &polymod, &Rg, &rho_g, &rho_dummy);
    SC_TIMER_STOP(timer);
#if DEBUG_GPV == 1
    fprintf(stderr, "Time to compute XGCD(g,phi): %3.3f sec\n", SC_TIMER_GET_ELAPSED(timer));
#endif
    SC_TIMER_RESET(timer);
    SC_TIMER_START(timer);

    sc_mpz_xgcd(&Rf, &Rg, &gcd1, &alpha, &beta);
    SC_TIMER_STOP(timer);
#if DEBUG_GPV == 1
    fprintf(stderr, "Time to compute GCD(Rf,Rg): %3.3f sec\n", SC_TIMER_GET_ELAPSED(timer));
#endif
    SC_TIMER_RESET(timer);
    SC_TIMER_START(timer);

    if (1 != sc_mpz_get_ui(&gcd1)) {
        // The gcd(Rf,Rg) and the computation of u and v are performed
        // together for efficiency
        num_retries++;
        goto step2;
    }
#if DEBUG_GPV == 1
    fprintf(stderr, "GCD(Rf,Rg) = 1\n");
#endif
    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "f", f, n);
    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "g", g, n);

    SC_TIMER_STOP(timer);
    SC_TIMER_STOP(total_timer);
#if DEBUG_GPV == 1
    fprintf(stderr, "Time to compute f and g: %3.3f sec\n", SC_TIMER_GET_ELAPSED(total_timer));
#endif

    SC_TIMER_RESET(timer);
    SC_TIMER_START(timer);
    SC_TIMER_START(total_timer);

    // Step 8. Calculate the polynomials F, G
    sc_mpz_mul_si(&qv, &beta, -q);
    sc_mpz_mul_si(&qu, &alpha, q);
    sc_poly_mpz_mul_scalar(&pF, &rho_g, &qv); // F = -q * rho_g * beta
    sc_poly_mpz_mul_scalar(&pG, &rho_f, &qu); // G = q * rho_f * alpha

    // Step 9. Calculate f-bar, g-bar and the reduction factor k
    sc_poly_mpz_reverse(&pfbar, n, &mp_f);
    sc_poly_mpz_reverse(&pgbar, n, &mp_g);

    // k = (F*fb + G*gb) / (f*fb + g*gb)
    sc_poly_mpz_mul(&temp, &mp_f, &pfbar);
    sc_poly_mpz_addmul(&temp, &mp_g, &pgbar);
    sc_poly_mpz_mod_ring(&den, n, &temp);

#if DEBUG_GPV == 1
    fprintf(stderr, "XGCD scale computation ...\n");
#endif
#ifdef ENABLE_CALLGRIND_PROFILING
    CALLGRIND_START_INSTRUMENTATION;
#endif
    SINT32 errcode = sc_poly_mpz_xgcd(&den, &polymod, &scale, &rho_g, &rho_dummy);
    if (SC_FUNC_FAILURE == errcode) {
        fprintf(stderr, "ERROR! sc_poly_mpz_xgcd() failed\n");
        goto finish;
    }
#ifdef ENABLE_CALLGRIND_PROFILING
    CALLGRIND_STOP_INSTRUMENTATION;
    CALLGRIND_DUMP_STATS;
#endif

    SC_TIMER_STOP(timer);
#if DEBUG_GPV == 1
    fprintf(stderr, "Time to scale: %3.3f sec\n", SC_TIMER_GET_ELAPSED(timer));
#endif
    SC_TIMER_RESET(timer);
    SC_TIMER_START(timer);

#if DEBUG_GPV == 1
    fprintf(stderr, "Computing reduction factor k ...\n");
#endif

    //poly_mpi_reset(&temp, 0);
    sc_poly_mpz_mul(&temp, &pF, &pfbar);
    sc_poly_mpz_addmul(&temp, &pG, &pgbar);
    sc_poly_mpz_mod_ring(&num, n, &temp);

    // den * rho_g + polymod * rho_dummy = gcd(den, polymod) = scale
    // => den * rho_g = scale
    // => 1/den = rho_g / scale
    // Therefore, k = num/den = num * rho_g / scale
    sc_poly_mpz_mul(&temp, &num, &rho_g);
    sc_poly_mpz_mod_ring(&k, n, &temp);
#if DEBUG_GPV == 1
    fprintf(stderr, "Scaling reduction factor k ...\n");
#endif
    for (size_t i=n; i--;) {
        sc_mpz_divquo(&k.p[i], &k.p[i], &scale);
    }

    // Step 10. Reduce F and G
#if DEBUG_GPV == 1
    fprintf(stderr, "Reducing F and G ...\n");
    /*fprintf(stderr, "k = \n");
    for (i=0; i<n; i++) {
        sc_mpz_out_str(stderr, 10, &k.p[i]);
        fprintf(stderr, " ");
        if (7 == (7&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");*/
#endif
    SINT32 deg_k = sc_poly_mpz_degree(&k);
    for (j=0; j<16; j++) {
    //while (deg_k >= 0 && !sc_mpz_is_zero(&k.p[0])) {
        sc_poly_mpz_mul(&temp, &k, &mp_f);
        sc_poly_mpz_sub(&temp, &pF, &temp);      // F = F - k*f
        sc_poly_mpz_mod_ring(&pF, n, &temp);
        sc_poly_mpz_mul(&temp, &k, &mp_g);
        sc_poly_mpz_sub(&temp, &pG, &temp);      // G = G - k*g
        sc_poly_mpz_mod_ring(&pG, n, &temp);

        sc_poly_mpz_mul(&temp, &pF, &pfbar);
        sc_poly_mpz_addmul(&temp, &pG, &pgbar);
        sc_poly_mpz_mod_ring(&num, n, &temp);

        sc_poly_mpz_mul(&temp, &num, &rho_g);
        sc_poly_mpz_mod_ring(&k, n, &temp);
        for (size_t i=n; i--;) {
            sc_mpz_divquo(&k.p[i], &k.p[i], &scale);
        }

        deg_k = sc_poly_mpz_degree(&k);
        if (0 == deg_k && sc_mpz_is_zero(&k.p[0])) {
            break;
        }
        if (15 == j) {
#if DEBUG_GPV == 1
            fprintf(stderr, "Cannot reduce F and G ...\n");
#endif
            num_retries++;
            goto finish;
        }
    }

    for (i=n; i--;) {
        F[i] = sc_poly_mpz_get_si(&pF, i);
        G[i] = sc_poly_mpz_get_si(&pG, i);
    }


#if DEBUG_GPV == 1
    fprintf(stderr, "\n");
    fprintf(stderr, "f = \n");
    for (i=0; i<n; i++) {
        fprintf(stderr, "%6d ", f[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
    fprintf(stderr, "g = \n");
    for (i=0; i<n; i++) {
        fprintf(stderr, "%6d ", g[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
    SINT32 sum = 0;
    fprintf(stderr, "F = \n");
    for (i=0; i<n; i++) {
        sum += F[i] * F[i];
        fprintf(stderr, "%6d ", F[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n(SUM = %d)\n", sum);
    sum = 0;
    fprintf(stderr, "G = \n");
    for (i=0; i<n; i++) {
        sum += G[i] * G[i];
        fprintf(stderr, "%6d ", G[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n(SUM = %d)\n", sum);

    fprintf(stderr, "Verifying master key ...\n");
#endif


    poly_si32_to_mpi(&mp_f, n, f);
    poly_si32_to_mpi(&mp_g, n, g);
    poly_si32_to_mpi(&pF, n, F);
    poly_si32_to_mpi(&pG, n, G);

    // Verify that the NTRU equation is solved
    sc_poly_mpz_mul(&temp, &pG, &mp_f);
    sc_poly_mpz_submul(&temp, &pF, &mp_g);      // F = F - k*f
    sc_poly_mpz_mod_ring(&temp, n, &temp);
    UINT32 verify = sc_mpz_get_ui(&temp.p[0]);

#if DEBUG_GPV == 1
    fprintf(stderr, "    q = 0x%08X, f*G - g*F = 0x%08X :: %s\n",
        q, verify, (q == verify)? "VERIFIED" : "FAILED");
#endif
    if (q != verify) {
        num_retries++;
        goto step2;
    }


    // Step 11. Compute the public key h = g/f mod q
    sc_mod_t modulus;
    limb_mod_init(&modulus, q);

    // Don't need this as it's done above ...
    //poly_mpi_xgcd(&mp_f, &polymod, &Rg, &rho_dummy, &rho_f);

    sc_poly_mpz_xgcd(&mp_f, &polymod, &Rf, &rho_f, &rho_dummy);
    sc_mpz_invmod(&Rf, &Rf, &mp_q);
    sc_poly_mpz_mul_scalar(&inv_f, &rho_f, &Rf);

    sc_poly_mpz_mul(&temp, &inv_f, &mp_f);
    sc_poly_mpz_mod_ring(&temp, n, &temp);
    sc_poly_mpz_mod(&temp, &temp, &modulus);

    for (i=0; i<n; i++) {
        sc_slimb_t val = sc_poly_mpz_get_si(&temp, i);
        if (0 == i && 1 != val) {
            num_retries++;
            goto step2;
        }
        if (0 != i && 0 != val) {
            num_retries++;
            goto step2;
        }
    }

    sc_poly_mpz_mul(&temp, &mp_g, &inv_f);
    sc_poly_mpz_mod_ring(&temp, n, &temp);
    sc_poly_mpz_mod(&temp, &temp, &modulus);

    for (i=n; i--;) {
        h[i] = sc_poly_mpz_get_si(&temp, i);
    }

#if DEBUG_GPV == 1
    fprintf(stderr, "\nh = g/f mod q =\n");
    for (i=0; i<n; i++) {
        sc_mpz_out_str(stderr, 10, &temp.p[i]);
        fprintf(stderr, " ");
        if (7 == (7&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
#endif

    retval = num_retries;

#if DEBUG_GPV == 1
    fprintf(stderr, "Polynomial basis found\n");
#endif

finish:
    sc_poly_mpz_clear(&inv_f);
    sc_mpz_clear(&Rf);
    sc_mpz_clear(&Rg);
    sc_mpz_clear(&gcd1);
    sc_mpz_clear(&gcd2);
    sc_poly_mpz_clear(&polymod);
    sc_poly_mpz_clear(&rho_f);
    sc_poly_mpz_clear(&rho_g);
    sc_poly_mpz_clear(&rho_dummy);
    sc_mpz_clear(&alpha);
    sc_mpz_clear(&beta);
    sc_poly_mpz_clear(&mp_f);
    sc_poly_mpz_clear(&mp_g);
    sc_mpz_clear(&mp_q);
    sc_poly_mpz_clear(&pF);
    sc_poly_mpz_clear(&pG);
    sc_mpz_clear(&qv);
    sc_mpz_clear(&qu);
    sc_mpz_clear(&scale);
    sc_poly_mpz_clear(&pfbar);
    sc_poly_mpz_clear(&pgbar);
    sc_poly_mpz_clear(&temp);
    sc_poly_mpz_clear(&num);
    sc_poly_mpz_clear(&den);
    sc_poly_mpz_clear(&k);

    SC_TIMER_STOP(timer);
    SC_TIMER_STOP(total_timer);
#if DEBUG_GPV == 1
    fprintf(stderr, "Time to compute F, G and h: %3.3f sec\n", SC_TIMER_GET_ELAPSED(timer));
    fprintf(stderr, "Total time: %3.3f sec\n", SC_TIMER_GET_ELAPSED(total_timer));
#endif

    SC_TIMER_DESTROY(timer);
    SC_TIMER_DESTROY(total_timer);

    return retval;
}

static SINT32 gpv_gen_basis_enhanced(safecrypto_t *sc, SINT32 *f, SINT32 *g, SINT32 *h,
    size_t n, SINT32 q,
    utils_sampling_t *sampling, prng_ctx_t *prng_ctx,
    SINT32 *F, SINT32 *G, SINT32 recreate_flag)
{
    size_t i, j;
    DOUBLE sigma;
    DOUBLE gs_norm;
    SINT32 retval = -1, num_retries = 0;
    UINT32 ter = n == 768;

#if DEBUG_GPV == 1
    SC_TIMER_INSTANCE(timer);
    SC_TIMER_CREATE(timer);
    SC_TIMER_RESET(timer);

    SC_TIMER_INSTANCE(total_timer);
    SC_TIMER_CREATE(total_timer);
    SC_TIMER_RESET(total_timer);

    SC_TIMER_START(timer);
    SC_TIMER_START(total_timer);
#endif

    ntt_params_t *ntt_params = (SC_SCHEME_SIG_FALCON == sc->scheme)? &sc->falcon->ntt  :
                               (SC_SCHEME_IBE_DLP    == sc->scheme)? &sc->dlp_ibe->ntt :
                                                                     &sc->ens_dlp_sig->ntt;
    const SINT16 *ntt_w_16 = (SC_SCHEME_SIG_FALCON == sc->scheme)? sc->falcon->params->w  :
                             (SC_SCHEME_IBE_DLP    == sc->scheme)? 0 :
                                                                   sc->ens_dlp_sig->params->w;
    const SINT16 *ntt_r_16 = (SC_SCHEME_SIG_FALCON == sc->scheme)? sc->falcon->params->r  :
                             (SC_SCHEME_IBE_DLP    == sc->scheme)? 0 :
                                                                   sc->ens_dlp_sig->params->r;
    const SINT32 *ntt_w_32 = (SC_SCHEME_IBE_DLP == sc->scheme)? sc->dlp_ibe->params->w : 0;
    const SINT32 *ntt_r_32 = (SC_SCHEME_IBE_DLP == sc->scheme)? sc->dlp_ibe->params->r : 0;

    falcon_keygen *fk = falcon_keygen_new(sc, 768 == n, ntt_params, ntt_w_16, ntt_r_16, sc_log2_32(n));

    // Step 1. set standard deviation of Gaussian distribution
    DOUBLE bd;
    bd  = 1.17*sqrt(q);

    // Step 2. Obtain f, g using Gaussian Samplers
    sigma  = 1.17 * sqrt(q / (2*n));
#if DEBUG_GPV == 1
    fprintf(stderr, "n=%zu, q=%d\n", n, q);
#endif
step2:
    // If f and g are already provided as inputs as we are recreating F and G
    // then do not sample new distributions
    if (0 == recreate_flag) {
    if (ter)
    {
        for (;;) {
            size_t u;
            DOUBLE *rt1, *rt2, *rt3;
            size_t hn;
            DOUBLE sigma, norm, bound;
            size_t logn = 9;

            hn = n >> 1;

            /*
             * Generate f and g in FFT representation (in rt1
             * and rt2, respectively); we must then convert
             * them back to non-FFT to apply rounding.
             */
            DOUBLE temp[3*n];
            rt1 = temp;
            rt2 = rt1 + n;
            rt3 = rt2 + n;
            sigma = sqrt(18433 / sqrt(8));
#if 1
            get_vector_32(sampling, f, n, 0);
            get_vector_32(sampling, g, n, 0);
#else
            /*
             * Generate f and g in FFT representation (in rt1
             * and rt2, respectively); we must then convert
             * them back to non-FFT to apply rounding.
             */
            for (u = 0; u < hn; u ++) {
                uint32_t a, b;
                uint64_t c;

                c = prng_64(prng_ctx);
                a = (uint32_t)c;
                b = (uint32_t)(c >> 32);
                fpr_gauss(&rt1[u], &rt1[u + hn], sigma, a, b);
                c = prng_64(prng_ctx);
                a = (uint32_t)c;
                b = (uint32_t)(c >> 32);
                fpr_gauss(&rt2[u], &rt2[u + hn], sigma, a, b);
            }
            falcon_iFFT3(rt1, logn, 1);
            falcon_iFFT3(rt2, logn, 1);
            for (u = 0; u < n; u ++) {
                f[u] = (int16_t)fpr_rint(rt1[u]);
                g[u] = (int16_t)fpr_rint(rt2[u]);
            }
#endif

            if (mod2_res_ternary(f, logn) == 0) {
                continue;
            }
            if (mod2_res_ternary(g, logn) == 0) {
                continue;
            }

            /*
             * Convert back to FFT to compute norms. Bound on
             * the squared norm of (g,-f) (in FFT representation)
             * is 4*N*q/sqrt(8).
             *
             * Note that our FFT contains only half the values,
             * so we must double the sum.
             */
            bound = (DOUBLE)(73732L * (long)n) / sqrt(8.0);

            poly_small_to_fp(rt1, f, logn, 1);
            poly_small_to_fp(rt2, g, logn, 1);

            /*fprintf(stderr, "\n");
    fprintf(stderr, "f = \n");
    for (i=0; i<n; i++) {
        fprintf(stderr, "%d ", f[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
    fprintf(stderr, "g = \n");
    for (i=0; i<n; i++) {
        fprintf(stderr, "%d ", g[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");

            fprintf(stderr, "\n");
    fprintf(stderr, "f = \n");
    for (i=0; i<n; i++) {
        fprintf(stderr, "%f ", rt1[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
    fprintf(stderr, "g = \n");
    for (i=0; i<n; i++) {
        fprintf(stderr, "%f ", rt2[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");*/

            falcon_FFT3(rt1, logn, 1);
            falcon_FFT3(rt2, logn, 1);
            norm = 0.0;
            for (u = 0; u < n; u ++) {
                norm = fpr_add(norm, fpr_sqr(rt1[u]));
                norm = fpr_add(norm, fpr_sqr(rt2[u]));
            }
            norm = fpr_double(norm);

            if (!fpr_lt(norm, bound)) {
                continue;
            }

            /*
             * Orthogonalized vector.
             */
            falcon_poly_invnorm2_fft3(rt3, rt1, rt2, logn, 1);
            falcon_poly_adj_fft3(rt1, logn, 1);
            falcon_poly_adj_fft3(rt2, logn, 1);
            falcon_poly_mulconst_fft3(rt1, 18433, logn, 1);
            falcon_poly_mulconst_fft3(rt2, 18433, logn, 1);
            falcon_poly_mul_autoadj_fft3(rt1, rt3, logn, 1);
            falcon_poly_mul_autoadj_fft3(rt2, rt3, logn, 1);
            norm = 0.0;
            for (u = 0; u < n; u ++) {
                norm = fpr_add(norm, fpr_sqr(rt1[u]));
                norm = fpr_add(norm, fpr_sqr(rt2[u]));
            }
            norm = fpr_double(norm);

            if (!fpr_lt(norm, bound)) {
                continue;
            }

    /*fprintf(stderr, "\n");
    fprintf(stderr, "f = \n");
    for (i=0; i<n; i++) {
        fprintf(stderr, "%6d ", f[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
    fprintf(stderr, "g = \n");
    for (i=0; i<n; i++) {
        fprintf(stderr, "%6d ", g[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");*/
            break;
        }
    }
    else {
        get_vector_32(sampling, f, n, 0);
        get_vector_32(sampling, g, n, 0);

    // Step 3. calculate the GramSchmidt norm
    gs_norm = gram_schmidt_norm(f, g, n, q, bd);
    if (isnanl(gs_norm)) {
        num_retries++;
        goto step2;
    }

    // Step 4. check whether norm is small enough; if not, repeat
    if (gs_norm > bd) {
        num_retries++;
        goto step2;
    }
#if DEBUG_GPV == 1
    fprintf(stderr, "GS=%3.3f, threshold=%3.3f\n", gs_norm, bd);

    SC_TIMER_STOP(timer);
    fprintf(stderr, "Time to compute GS Norm: %3.3f sec\n", SC_TIMER_GET_ELAPSED(timer));
    SC_TIMER_RESET(timer);
    SC_TIMER_START(timer);
#endif

    }
    }
    else {
        // If we are recreating the private key and we require a restart then
        // there has been an error
        goto finish;
    }

    // Steps 5, 6, 7, 8, 9 and 10
    if (!solve_NTRU(fk, F, G, f, g, q < 0x10000)) {
        num_retries++;
        goto step2;
    }

#if DEBUG_GPV == 1
    fprintf(stderr, "\n");
    fprintf(stderr, "f = \n");
    for (i=0; i<n; i++) {
        fprintf(stderr, "%6d ", f[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
    fprintf(stderr, "g = \n");
    for (i=0; i<n; i++) {
        fprintf(stderr, "%6d ", g[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n");
    SINT32 sum = 0;
    fprintf(stderr, "F = \n");
    for (i=0; i<n; i++) {
        sum += F[i] * F[i];
        fprintf(stderr, "%6d ", F[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n(SUM = %d)\n", sum);
    sum = 0;
    fprintf(stderr, "G = \n");
    for (i=0; i<n; i++) {
        sum += G[i] * G[i];
        fprintf(stderr, "%6d ", G[i]);
        if (15 == (15&i)) fprintf(stderr, "\n");
    }
    fprintf(stderr, "\n(SUM = %d)\n", sum);

    fprintf(stderr, "Verifying master key ...\n");
#endif

    // Step 11. Compute the public key h = g/f mod q
    if (SC_FUNC_FAILURE == create_public_key_32(h, f, g, q, n, ter)) {
        num_retries++;
        goto step2;
    }

    falcon_keygen_free(fk);

    retval = num_retries;

#if DEBUG_GPV == 1
    fprintf(stderr, "Polynomial basis found\n");
#endif

finish:
#if DEBUG_GPV == 1
    SC_TIMER_STOP(timer);
    SC_TIMER_STOP(total_timer);
    fprintf(stderr, "Time to compute F, G and h: %3.3f sec\n", SC_TIMER_GET_ELAPSED(timer));
    fprintf(stderr, "Total time: %3.3f sec\n", SC_TIMER_GET_ELAPSED(total_timer));

    SC_TIMER_DESTROY(timer);
    SC_TIMER_DESTROY(total_timer);
#endif

    return retval;
}

SINT32 gpv_gen_basis(safecrypto_t *sc, SINT32 *f, SINT32 *g, SINT32 *h,
    size_t n, SINT32 q,
    utils_sampling_t *sampling, prng_ctx_t *prng_ctx,
    SINT32 *F, SINT32 *G, SINT32 recreate_flag)
{
#if CRT_NTRU_SOLVE == 0
    gpv_gen_basis_original(sc, f, g, h, n, q, sampling, prng_ctx, F, G, recreate_flag);
#else
    gpv_gen_basis_enhanced(sc, f, g, h, n, q, sampling, prng_ctx, F, G, recreate_flag);
#endif
}

SINT32 gaussian_lattice_sample_on_the_fly_flt(safecrypto_t *sc,
    const gpv_t *gpv, const FLOAT *b_gs, const FLOAT *b_gs_inv_norm,
    const SINT32 *c, SINT32 *v, UINT32 q, DOUBLE s_f)
{
    size_t i, j;
    size_t n = gpv->n;

    SINT64 ci[2*n];
    for (j=n; j--;) {
        ci[j] = c[j];
        ci[n+j] = 0;
    }

    SC_PRINT_DEBUG(sc, "s_f = %3.6Lf\n", s_f);
    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "H(id)", c, n);

    // Adaptive Gaussian Sampling
    utils_sampling_t *gauss = NULL;
    FLOAT sig = 0L;
    for (j=2*n; j--;) {
        FLOAT d, dot_product;
        dot_product = dot_s64_flt(ci, b_gs, 2*n, 0, j);
        d   = dot_product * b_gs_inv_norm[j] * b_gs_inv_norm[j];

        if (0L == sig) {
            sig = s_f * b_gs_inv_norm[j];

            gauss = create_sampler(
                sc->sampling, SAMPLING_64BIT, sc->blinding, 1, SAMPLING_DISABLE_BOOTSTRAP,
                sc->prng_ctx[0], 10, sig);
            if (NULL == gauss) {
                return SC_FUNC_FAILURE;
            }
        }

        SINT32 z;
        z = get_sample(gauss) + (SINT32) d;

        for (i=0; i<2*n; i++) {
            ci[i] -= z * gpv_read_basis(gpv, j, i);
        }

        if (j == n) {
            sig = 0L;
            destroy_sampler(&gauss);
        }
    }
    destroy_sampler(&gauss);

    // Output final vector - only the latter half of "c - ci" is needed where
    // c is actually 0 for n to 2n-1
    for (j=0; j<n; j++) {
        v[j] = ci[n+j];
    }

    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "User Secret Key", v, n);

    return SC_FUNC_SUCCESS;
}

SINT32 gaussian_lattice_sample_on_the_fly_dbl(safecrypto_t *sc,
    const gpv_t *gpv, const DOUBLE *b_gs, const DOUBLE *b_gs_inv_norm,
    const SINT32 *c, SINT32 *v, UINT32 q, DOUBLE s_f)
{
    size_t i, j;
    size_t n = gpv->n;

    SINT64 ci[2*n];
    for (j=n; j--;) {
        ci[j] = c[j];
        ci[n+j] = 0;
    }

    SC_PRINT_DEBUG(sc, "s_f = %3.6Lf\n", s_f);
    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "H(id)", c, n);

    // Adaptive Gaussian Sampling
    utils_sampling_t *gauss = NULL;
    DOUBLE sig = 0L;
    for (j=2*n; j--;) {
        DOUBLE d, dot_product;
        dot_product = dot_s64_dbl(ci, b_gs, 2*n, 0, j);
        d   = dot_product * b_gs_inv_norm[j] * b_gs_inv_norm[j];

        if (0L == sig) {
            sig = s_f * b_gs_inv_norm[j];

            gauss = create_sampler(
                sc->sampling, SAMPLING_64BIT, sc->blinding, 1, SAMPLING_DISABLE_BOOTSTRAP,
                sc->prng_ctx[0], 10, sig);
            if (NULL == gauss) {
                return SC_FUNC_FAILURE;
            }
        }

        SINT32 z;
        z = get_sample(gauss) + (SINT32) d;

        for (i=0; i<2*n; i++) {
            ci[i] -= z * gpv_read_basis(gpv, j, i);
        }

        if (j == n) {
            sig = 0L;
            destroy_sampler(&gauss);
        }
    }
    destroy_sampler(&gauss);

    // Output final vector - only the latter half of "c - ci" is needed where
    // c is actually 0 for n to 2n-1
    for (j=0; j<n; j++) {
        v[j] = ci[n+j];
    }

    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "User Secret Key", v, n);

    return SC_FUNC_SUCCESS;
}

SINT32 gaussian_lattice_sample_on_the_fly_ldbl(safecrypto_t *sc,
    const gpv_t *gpv, const LONGDOUBLE *b_gs, const LONGDOUBLE *b_gs_inv_norm,
    const SINT32 *c, SINT32 *v, UINT32 q, DOUBLE s_f)
{
    size_t i, j;
    size_t n = gpv->n;

    LONGDOUBLE ci[2*n];
    for (j=n; j--;) {
        ci[j] = c[j];
        ci[n+j] = 0;
    }

    SC_PRINT_DEBUG(sc, "s_f = %3.6Lf\n", s_f);
    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "H(id)", c, n);

    // Adaptive Gaussian Sampling
    utils_sampling_t *gauss = NULL;
    LONGDOUBLE sig = 0L;
    for (j=2*n; j--;) {
        LONGDOUBLE d, dot_product;
        dot_product = dot_ldbl(ci, b_gs, 2*n, 0, j);
        d   = dot_product * b_gs_inv_norm[j] * b_gs_inv_norm[j];

        if (0L == sig) {
            sig = s_f * b_gs_inv_norm[j];

            gauss = create_sampler(
                sc->sampling, SAMPLING_64BIT, sc->blinding, 1, SAMPLING_DISABLE_BOOTSTRAP,
                sc->prng_ctx[0], 10, sig);
            if (NULL == gauss) {
                return SC_FUNC_FAILURE;
            }
        }

        SINT32 z;
        z = get_sample(gauss) + (SINT32) d;

        for (i=0; i<2*n; i++) {
            ci[i] -= z * gpv_read_basis(gpv, j, i);
        }

        if (j == n) {
            sig = 0L;
            destroy_sampler(&gauss);
        }
    }
    destroy_sampler(&gauss);

    // Output final vector - only the latter half of "c - ci" is needed where
    // c is actually 0 for n to 2n-1
    for (j=0; j<n; j++) {
        v[j] = ci[n+j];
    }

    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "User Secret Key", v, n);

    return SC_FUNC_SUCCESS;
}

SINT32 gaussian_lattice_sample_flt(safecrypto_t *sc,
    const gpv_t *gpv, const FLOAT *b_gs, const FLOAT *b_gs_inv_norm,
    const SINT32 *c, SINT32 *v1, SINT32 *v2,
    UINT32 q, DOUBLE s_f, UINT32 flags)
{
    size_t i, j;
    size_t n = gpv->n;
    SINT64 z;
    SINT32 is_efficient = flags & GPV_GAUSSIAN_SAMPLE_EFFICIENT;

    SINT64 ci[2*n];
    for (j=n; j--;) {
        ci[j] = c[j];
        ci[n+j] = 0;
    }

    SC_PRINT_DEBUG(sc, "s_f = %3.6Lf\n", s_f);
    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "H(id)", c, n);

    // Adaptive Gaussian Sampling
    utils_sampling_t *gauss = NULL;
    if (flags & GPV_GAUSSIAN_SAMPLE_MW_BOOTSTRAP) {
        gauss = sc->sc_gauss;
    }
    FLOAT sig = 0L;
    for (j=2*n; j--;) {
        FLOAT d, dot_product;
        dot_product = dot_s64_flt(ci, b_gs, 2*n, 0, j);
        d = dot_product * b_gs_inv_norm[j] * b_gs_inv_norm[j];

        if (flags & GPV_GAUSSIAN_SAMPLE_MW_BOOTSTRAP) {
            sig = s_f * b_gs_inv_norm[j];
            z = get_bootstrap_sample(gauss, sig, d);
        }
        else {
            if ((is_efficient && (0L == sig)) || !is_efficient) {
                sig = s_f * b_gs_inv_norm[j];
    
                gauss = create_sampler(
                    sc->sampling, SAMPLING_64BIT, sc->blinding, 1, SAMPLING_DISABLE_BOOTSTRAP,
                    sc->prng_ctx[0], 10, sig);
                if (NULL == gauss) {
                    return SC_FUNC_FAILURE;
                }
            }
    
            z = get_sample(gauss) + (SINT32) d;
        }

        for (i=2*n; i--;) {
            ci[i] -= z * gpv->b[j*2*n + i];
        }

        if (!(flags & GPV_GAUSSIAN_SAMPLE_MW_BOOTSTRAP)) {
            if (flags & GPV_GAUSSIAN_SAMPLE_EFFICIENT) {
                if (j == n) {
                    sig = 0L;
                    destroy_sampler(&gauss);
                }
            }
            else {
                destroy_sampler(&gauss);
            }
        }
    }
    if (flags & GPV_GAUSSIAN_SAMPLE_EFFICIENT) {
        destroy_sampler(&gauss);
    }

    // Output final vector - only the latter half of "c - ci" is needed where
    // c is actually 0 for n to 2n-1
    for (j=0; j<n; j++) {
        v1[j] = ci[n+j];
    }
    if (v2) {
        for (j=0; j<n; j++) {
           v2[j] = ci[j];
        }
    }

    return SC_FUNC_SUCCESS;
}

SINT32 gaussian_lattice_sample_dbl(safecrypto_t *sc,
    const gpv_t *gpv, const DOUBLE *b_gs, const DOUBLE *b_gs_inv_norm,
    const SINT32 *c, SINT32 *v1, SINT32 *v2,
    UINT32 q, DOUBLE s_f, UINT32 flags)
{
    size_t i, j;
    size_t n = gpv->n;

    SINT64 ci[2*n];
    for (j=n; j--;) {
        ci[j] = c[j];
        ci[n+j] = 0;
    }

    SC_PRINT_DEBUG(sc, "s_f = %3.6Lf\n", s_f);
    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "H(id)", c, n);

    // Adaptive Gaussian Sampling
    utils_sampling_t *gauss = NULL;
    DOUBLE sig = 0L;
    for (j=2*n; j--;) {
        DOUBLE d, dot_product;
        dot_product = dot_s64_dbl(ci, b_gs, 2*n, 0, j);
        d = dot_product * b_gs_inv_norm[j] * b_gs_inv_norm[j];

        if (flags & GPV_GAUSSIAN_SAMPLE_EFFICIENT) {
            if (0L == sig) {
                sig = s_f * b_gs_inv_norm[j];

                gauss = create_sampler(
                    sc->sampling, SAMPLING_64BIT, sc->blinding, 1, SAMPLING_DISABLE_BOOTSTRAP,
                    sc->prng_ctx[0], 10, sig);
                if (NULL == gauss) {
                   return SC_FUNC_FAILURE;
                }
            }
        }
        else {
            sig = s_f * b_gs_inv_norm[j];

            gauss = create_sampler(
                sc->sampling, SAMPLING_64BIT, sc->blinding, 1, SAMPLING_DISABLE_BOOTSTRAP,
                sc->prng_ctx[0], 10, sig);
            if (NULL == gauss) {
                return SC_FUNC_FAILURE;
            }
        }

        SINT64 z;
        z = get_sample(gauss) + (SINT32) d;

        for (i=2*n; i--;) {
            ci[i] -= z * gpv->b[j*2*n + i];
        }

        if (flags & GPV_GAUSSIAN_SAMPLE_EFFICIENT) {
            if (j == n) {
                sig = 0L;
                destroy_sampler(&gauss);
            }
        }
        else {
            destroy_sampler(&gauss);
        }
    }
    if (flags & GPV_GAUSSIAN_SAMPLE_EFFICIENT) {
        destroy_sampler(&gauss);
    }

    // Output final vector - only the latter half of "c - ci" is needed where
    // c is actually 0 for n to 2n-1
    for (j=0; j<n; j++) {
        v1[j] = ci[n+j];
    }
    if (v2) {
        for (j=0; j<n; j++) {
           v2[j] = ci[j];
        }
    }

    return SC_FUNC_SUCCESS;
}

SINT32 gaussian_lattice_sample_ldbl(safecrypto_t *sc,
    const gpv_t *gpv, const LONGDOUBLE *b_gs, const LONGDOUBLE *b_gs_inv_norm,
    const SINT32 *c, SINT32 *v1, SINT32 *v2,
    UINT32 q, DOUBLE s_f, UINT32 flags)
{
    size_t i, j;
    size_t n = gpv->n;

    LONGDOUBLE ci[2*n];
    for (j=n; j--;) {
        ci[j] = c[j];
        ci[n+j] = 0;
    }

    SC_PRINT_DEBUG(sc, "s_f = %3.6Lf\n", s_f);
    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "H(id)", c, n);

    // Adaptive Gaussian Sampling
    utils_sampling_t *gauss = NULL;
    LONGDOUBLE sig = 0L;
    for (j=2*n; j--;) {
        LONGDOUBLE d, dot_product;
        dot_product = dot_ldbl(ci, b_gs, 2*n, 0, j);
        d = dot_product * b_gs_inv_norm[j] * b_gs_inv_norm[j];

        if (flags & GPV_GAUSSIAN_SAMPLE_EFFICIENT) {
            if (0L == sig) {
                sig = s_f * b_gs_inv_norm[j];

                gauss = create_sampler(
                    sc->sampling, SAMPLING_64BIT, sc->blinding, 1, SAMPLING_DISABLE_BOOTSTRAP,
                    sc->prng_ctx[0], 10, sig);
                if (NULL == gauss) {
                    return SC_FUNC_FAILURE;
                }
            }
        }
        else {
            sig = s_f * b_gs_inv_norm[j];

            gauss = create_sampler(
                sc->sampling, SAMPLING_64BIT, sc->blinding, 1, SAMPLING_DISABLE_BOOTSTRAP,
                sc->prng_ctx[0], 10, sig);
            if (NULL == gauss) {
                return SC_FUNC_FAILURE;
            }
        }

        SINT64 z;
        z = get_sample(gauss) + (SINT32) d;

        for (i=2*n; i--;) {
            ci[i] -= z * gpv->b[j*2*n + i];
        }

        if (flags & GPV_GAUSSIAN_SAMPLE_EFFICIENT) {
            if (j == n) {
                sig = 0L;
                destroy_sampler(&gauss);
            }
        }
        else {
            destroy_sampler(&gauss);
        }
    }
    if (flags & GPV_GAUSSIAN_SAMPLE_EFFICIENT) {
        destroy_sampler(&gauss);
    }

    // Output final vector - only the latter half of "c - ci" is needed where
    // c is actually 0 for n to 2n-1
    for (j=0; j<n; j++) {
        v1[j] = ci[n+j];
    }
    if (v2) {
        for (j=0; j<n; j++) {
           v2[j] = ci[j];
        }
    }

    return SC_FUNC_SUCCESS;
}

//fft sampler from FALCON:
/*
 * Perform Fast Fourier Sampling for target vector t and LDL tree T.
 * tmp[] must have size for at least two polynomials of size 2^logn.
 */
SINT32 gaussian_lattice_sample_fft(safecrypto_t *sc,
    DOUBLE *z0, DOUBLE *z1, DOUBLE *restrict tree,
    const DOUBLE *restrict t0, const DOUBLE *restrict t1, unsigned logn,
    DOUBLE *restrict tmp, UINT32 flags)
{
    size_t n, hn;
    DOUBLE *tree0, *tree1;
    n = (size_t)1 << logn;
    if (n == 1) {
        FLOAT sigma = tree[0];

        utils_sampling_t *gauss = create_sampler(
            sc->sampling, SAMPLING_64BIT, sc->blinding, 1, SAMPLING_DISABLE_BOOTSTRAP,
            sc->prng_ctx[0], 10, sigma);
        if (NULL == gauss) {
            fprintf(stderr, "null==gauss \n");
            return SC_FUNC_FAILURE;
        }
   
        z0[0] = floor(t0[0]) + get_sample(gauss);
        z1[0] = floor(t1[0]) + get_sample(gauss);

        destroy_sampler(&gauss);
        return SC_FUNC_SUCCESS;
    }

    hn = n >> 1;
    tree0 = tree + n;
    tree1 = tree + n + ffLDL_treesize(logn - 1);

    // We split t1 into z1 (reused as temporary storage), then do
    // the recursive invocation, with output in tmp. We finally
    // merge back into z1.
    falcon_poly_split_fft(z1, z1 + hn, t1, logn);
    gaussian_lattice_sample_fft(sc, tmp, tmp + hn,
            tree1, z1, z1 + hn, logn - 1, tmp + n, flags);
    falcon_poly_merge_fft(z1, tmp, tmp + hn, logn);

    // Compute tb0 = t0 + (t1 - z1) * L. Value tb0 ends up in tmp[].
    memcpy(tmp, t1, n * sizeof *t1);
    falcon_poly_sub(tmp, z1, logn);
    falcon_poly_mul_fft(tmp, tree, logn);
    falcon_poly_add(tmp, t0, logn);

    // Second recursive invocation.
    falcon_poly_split_fft(z0, z0 + hn, tmp, logn);
    gaussian_lattice_sample_fft(sc, tmp, tmp + hn,
            tree0, z0, z0 + hn, logn - 1, tmp + n, flags);
    falcon_poly_merge_fft(z0, tmp, tmp + hn, logn);

    return SC_FUNC_SUCCESS;
}

static SINT32
ffSampling_inner_fft3(safecrypto_t *sc,
    DOUBLE *restrict z0, DOUBLE *restrict z1,
    const DOUBLE *restrict tree,
    const DOUBLE *restrict t0, const DOUBLE *restrict t1,
    unsigned logn, DOUBLE *restrict tmp)
{
    size_t n, hn;
    DOUBLE *x0, *x1, *y0, *y1;
    const DOUBLE *tree0, *tree1;

    /*
     * For tree construction, recursion stopped at n = 2, but it
     * produced a tree which also covers n = 1. For sampling, we use
     * the fact that the split() and merge() function
     * implementations actually supports logn = 1.
     */
    if (logn == 0) {
        DOUBLE r0, r1, rx;
        DOUBLE sigma = tree[0];
        fprintf(stderr, "sigma = %f\n", sigma);

        utils_sampling_t *gauss = create_sampler(
            sc->sampling, SAMPLING_64BIT, sc->blinding, 1, SAMPLING_DISABLE_BOOTSTRAP,
            sc->prng_ctx[0], 10, fpr_IW1I * sigma);
        if (NULL == gauss) {
            fprintf(stderr, "null==gauss \n");
            return SC_FUNC_FAILURE;
        }

        r1 = *t1;
        r0 = *t0;
        r1 = - (DOUBLE) get_sample(gauss);
        destroy_sampler(&gauss);
        
        gauss = create_sampler(
            sc->sampling, SAMPLING_64BIT, sc->blinding, 1, SAMPLING_DISABLE_BOOTSTRAP,
            sc->prng_ctx[0], 10, sigma);
        if (NULL == gauss) {
            fprintf(stderr, "null==gauss \n");
            return SC_FUNC_FAILURE;
        }

        rx = r1 * 0.5;
        r0 = r0 + rx;
        r0 = - (DOUBLE) get_sample(gauss);
        destroy_sampler(&gauss);

        r0 = r0 - rx;
        *z0 = r0;
        *z1 = r1;
        return SC_FUNC_SUCCESS;
    }

    n = (size_t)1 << logn;
    hn = n >> 1;
    y0 = tmp;
    y1 = y0 + hn;

    tree0 = tree + n;
    tree1 = tree + n + (logn << (logn - 1));

    /*
     * Split t1, recurse, merge into z1.
     */
    x0 = z1;
    x1 = x0 + hn;
    falcon_poly_split_deep_fft3(x0, x1, t1, logn);
    ffSampling_inner_fft3(sc,
        y0, y1, tree1, x0, x1, logn - 1, tmp + n);
    falcon_poly_merge_deep_fft3(z1, y0, y1, logn);

    /*
     * Compute t0b = t0 + z1 * l10 (into tmp[]).
     * FIXME: save z1 * l10 instead of recomputing it later on.
     */
    memcpy(tmp, z1, n * sizeof *t1);
    falcon_poly_mul_fft3(tmp, tree, logn, 0);
    falcon_poly_add_fft3(tmp, t0, logn, 0);

    /*
     * Split t0b, recurse, merge into z0.
     */
    x0 = z0;
    x1 = x0 + hn;
    falcon_poly_split_deep_fft3(x0, x1, tmp, logn);
    ffSampling_inner_fft3(sc,
        y0, y1, tree0, x0, x1, logn - 1, tmp + n);
    falcon_poly_merge_deep_fft3(z0, y0, y1, logn);

    /*
     * Subtract z1 * l10 from z0.
     */
    memcpy(tmp, z1, n * sizeof *z1);
    falcon_poly_mul_fft3(tmp, tree, logn, 0);
    falcon_poly_sub_fft3(z0, tmp, logn, 0);

    return SC_FUNC_SUCCESS;
}

static void
ffSampling_depth1_fft3(safecrypto_t *sc,
    DOUBLE *restrict z0, DOUBLE *restrict z1, DOUBLE *restrict z2,
    const DOUBLE *restrict tree,
    const DOUBLE *restrict t0, const DOUBLE *restrict t1, const DOUBLE *restrict t2,
    unsigned logn, DOUBLE *restrict tmp)
{
    size_t n, hn;
    DOUBLE *x0, *x1, *y0, *y1;
    const DOUBLE *tree0, *tree1, *tree2;

    n = (size_t)1 << logn;
    hn = n >> 1;

    tree0 = tree + 3 * n;
    tree1 = tree0 + (logn << (logn - 1));
    tree2 = tree1 + (logn << (logn - 1));
    y0 = tmp;
    y1 = y0 + hn;

    /*
     * Split t2, recurse, merge into z2.
     */
    x0 = z2;
    x1 = x0 + hn;
    falcon_poly_split_deep_fft3(x0, x1, t2, logn);
    ffSampling_inner_fft3(sc,
        y0, y1, tree2, x0, x1, logn - 1, tmp + n);
    falcon_poly_merge_deep_fft3(z2, y0, y1, logn);

    /*
     * Compute t1b = t1 + z2 * l21 (into tmp[]).
     * FIXME: save z2 * l21 instead of recomputing it later on.
     */
    memcpy(tmp, z2, n * sizeof *z2);
    falcon_poly_mul_fft3(tmp, tree + 2 * n, logn, 0);
    falcon_poly_add_fft3(tmp, t1, logn, 0);

    /*
     * Split t1b, recurse, merge into z1, and subtract z2 * l21.
     */
    x0 = z1;
    x1 = x0 + hn;
    falcon_poly_split_deep_fft3(x0, x1, tmp, logn);
    ffSampling_inner_fft3(sc,
        y0, y1, tree1, x0, x1, logn - 1, tmp + n);
    falcon_poly_merge_deep_fft3(z1, y0, y1, logn);
    memcpy(tmp, z2, n * sizeof *z2);
    falcon_poly_mul_fft3(tmp, tree + 2 * n, logn, 0);
    falcon_poly_sub_fft3(z1, tmp, logn, 0);

    /*
     * Compute t0b = t0 + z1 * l10 + z2 * l20 (into z0).
     * We use z0 as extra temporary.
     * FIXME: save z1 * l10 + z2 * l20 instead of recomputing it later on.
     */
    memcpy(z0, t0, n * sizeof *t0);
    memcpy(tmp, z1, n * sizeof *z1);
    falcon_poly_mul_fft3(tmp, tree, logn, 0);
    falcon_poly_add_fft3(z0, tmp, logn, 0);
    memcpy(tmp, z2, n * sizeof *z1);
    falcon_poly_mul_fft3(tmp, tree + n, logn, 0);
    falcon_poly_add_fft3(z0, tmp, logn, 0);

    /*
     * Split t0b, recurse, merge into z0.
     */
    x0 = z0;
    x1 = x0 + hn;
    memcpy(tmp, z0, n * sizeof *z0);
    falcon_poly_split_deep_fft3(x0, x1, tmp, logn);
    ffSampling_inner_fft3(sc,
        y0, y1, tree0, x0, x1, logn - 1, tmp + n);
    falcon_poly_merge_deep_fft3(z0, y0, y1, logn);

    /*
     * Subtract z1 * l10 and z2 * l20 from z0.
     */
    memcpy(tmp, z1, n * sizeof *z1);
    falcon_poly_mul_fft3(tmp, tree, logn, 0);
    falcon_poly_sub_fft3(z0, tmp, logn, 0);
    memcpy(tmp, z2, n * sizeof *z1);
    falcon_poly_mul_fft3(tmp, tree + n, logn, 0);
    falcon_poly_sub_fft3(z0, tmp, logn, 0);
}

SINT32 gaussian_lattice_sample_fft3(safecrypto_t *sc,
    DOUBLE *z0, DOUBLE *z1, DOUBLE *restrict tree,
    const DOUBLE *restrict t0, const DOUBLE *restrict t1, unsigned logn,
    DOUBLE *restrict tmp, UINT32 flags)
{
    size_t n, tn;
    DOUBLE *x0, *x1, *x2, *y0, *y1, *y2;
    const DOUBLE *tree0, *tree1;

    n = (size_t)3 << (logn - 1);
    tn = (size_t)1 << (logn - 1);

    tree0 = tree + n;
    tree1 = tree0 + 3 * ((logn + 1) << (logn - 2));
    y0 = tmp;
    y1 = y0 + tn;
    y2 = y1 + tn;

    /*
     * We split t1 three ways for recursive invocation. We use
     * z0 and z1 as temporary storage areas; final merge yields z1.
     */
    x0 = z1;
    x1 = x0 + tn;
    x2 = x1 + tn;
    falcon_poly_split_top_fft3(x0, x1, x2, t1, logn);
    ffSampling_depth1_fft3(sc,
        y0, y1, y2, tree1, x0, x1, x2, logn - 1, tmp + n);
    falcon_poly_merge_top_fft3(z1, y0, y1, y2, logn);

    /*
     * Compute t0b = t0 + z1 * L (in tmp[]).
     * FIXME: save z1 * L instead of recomputing it later on.
     */
    memcpy(tmp, z1, n * sizeof *z1);
    falcon_poly_mul_fft3(tmp, tree, logn, 1);
    falcon_poly_add_fft3(tmp, t0, logn, 1);

    /*
     * Split t0b, recurse, and merge into z0.
     */
    x0 = z0;
    x1 = x0 + tn;
    x2 = x1 + tn;
    falcon_poly_split_top_fft3(x0, x1, x2, tmp, logn);
    ffSampling_depth1_fft3(sc,
        y0, y1, y2, tree0, x0, x1, x2, logn - 1, tmp + n);
    falcon_poly_merge_top_fft3(z0, y0, y1, y2, logn);

    /*
     * Subtract z1 * L from z0.
     */
    memcpy(tmp, z1, n * sizeof *z1);
    falcon_poly_mul_fft3(tmp, tree, logn, 1);
    falcon_poly_sub_fft3(z0, tmp, logn, 1);

    return SC_FUNC_SUCCESS;
}

SINT32 gaussian_sample_with_tree(safecrypto_t *sc, DOUBLE *sk, UINT32 ter,
    UINT32 n, UINT32 q, UINT32 n_bits,
    SINT32 *c, UINT32 gaussian_flags, SINT32 *s1, SINT32 *s2)
{
    SINT32 retval = SC_FUNC_FAILURE;
    size_t i;
    DOUBLE *c0, *c1, *tmp, *z0, *z1;
    DOUBLE ni;
    DOUBLE *b00, *b01, *b10, *b11, *tree;

    // Assign pointers for the pre-computed Falcon tree
    b00      = sk + skoff_b00(n_bits, ter);
    b01      = sk + skoff_b01(n_bits, ter);
    b10      = sk + skoff_b10(n_bits, ter);
    b11      = sk + skoff_b11(n_bits, ter);
    tree     = sk + skoff_tree(n_bits, ter);

    // Allocate memory for FALCON signature sampling_fft
    c0 = SC_MALLOC(sizeof(DOUBLE) * 11 * n);
    if (NULL == c0) {
        SC_LOG_ERROR(sc, SC_NULL_POINTER);
        return SC_FUNC_FAILURE;
    }
    c1       = c0 + n;
    tmp      = c1 + n;
    z0       = tmp + 7 * n;
    z1       = z0 + n;

    // Copy the message ring to a floating point representation for use with
    // the FFT (c1 is 0, but s modified later so does not require setting to 0 here)
    for (int i = 0; i < n; i ++) {
        c0[i] = c[i];
    }

    ni       = fpr_inverse_of(q);

    if (ter) {
        falcon_FFT3(c0, n_bits, 1);
        memcpy(c1, c0, n * sizeof(DOUBLE));
        falcon_poly_mul_fft3(c1, b01, n_bits, 1);
        falcon_poly_mulconst_fft3(c1, fpr_neg(ni), n_bits, 1);
        falcon_poly_mul_fft3(c0, b11, n_bits, 1);
        falcon_poly_mulconst_fft3(c0, ni, n_bits, 1);

        // Generate a sampled polynomial using the polynomial basis
        SINT32 sample_error;
        sample_error = gaussian_lattice_sample_fft3(sc, z0, z1, tree, c0, c1, n_bits, tmp, gaussian_flags);
        if (SC_FUNC_FAILURE == sample_error) {
            SC_LOG_ERROR(sc, SC_ERROR);
            goto finish;
        }

        // Get the lattice point of the Gaussian sampled vector
        memcpy(c0, z0, n * sizeof(DOUBLE));
        memcpy(c1, z1, n * sizeof(DOUBLE));
        falcon_poly_mul_fft3(z0, b00, n_bits, 1);
        falcon_poly_mul_fft3(z1, b10, n_bits, 1);
        falcon_poly_add_fft3(z0, z1, n_bits, 1);
        memcpy(z1, c0, n * sizeof(DOUBLE));
        falcon_poly_mul_fft3(z1, b01, n_bits, 1);

        memcpy(c0, z0, n * sizeof(DOUBLE));
        falcon_poly_mul_fft3(c1, b11, n_bits, 1);
        falcon_poly_add_fft3(c1, z1, n_bits, 1);

        falcon_iFFT3(c0, n_bits, 1);
        falcon_iFFT3(c1, n_bits, 1);

        // Compute the signature or IBE user key
        if (s1) {
            for (int i = 0; i < n; i ++) {
                s1[i] = (SINT32) llrint(c0[i]);
            }
        }
        for (int i = 0; i < n; i ++) {
            s2[i] = (SINT32) llrint(c1[i]);
        }
    }
    else {
        /// @todo Is this mapping the message ring to the poly basis of the secret key?
        falcon_FFT(c0, n_bits);
        memcpy(c1, c0, n * sizeof(DOUBLE));
        falcon_poly_mul_fft(c1, b01, n_bits);
        falcon_poly_mulconst_fft(c1, fpr_neg(ni), n_bits);
        falcon_poly_mul_fft(c0, b11, n_bits);
        falcon_poly_mulconst_fft(c0, ni, n_bits);

        // Generate a sampled polynomial using the polynomial basis
        SINT32 sample_error;
        sample_error = gaussian_lattice_sample_fft(sc, z0, z1, tree, c0, c1, n_bits, tmp, gaussian_flags);
        if (SC_FUNC_FAILURE == sample_error) {
            SC_LOG_ERROR(sc, SC_ERROR);
            goto finish;
        }

        // Get the lattice point of the Gaussian sampled vector
        memcpy(c0, z0, n * sizeof(DOUBLE));
        memcpy(c1, z1, n * sizeof(DOUBLE));
        falcon_poly_mul_fft(z0, b00, n_bits);
        falcon_poly_mul_fft(z1, b10, n_bits);
        falcon_poly_add(z0, z1, n_bits);
        memcpy(z1, c0, n * sizeof(DOUBLE));
        falcon_poly_mul_fft(z1, b01, n_bits);

        memcpy(c0, z0, n * sizeof(DOUBLE));
        falcon_poly_mul_fft(c1, b11, n_bits);
        falcon_poly_add(c1, z1, n_bits);

        // The result is in FFT domain, so convert back
        falcon_iFFT(c0, n_bits);
        falcon_iFFT(c1, n_bits);

        // Compute the signature or IBE user key
        if (s1) {
            for (int i = 0; i < n; i ++) {
                s1[i] = (SINT32)(c[i] - llrint(c0[i]));
            }
        }
        for (int i = 0; i < n; i ++) {
            s2[i] = (SINT32) -llrint(c1[i]);
        }
    }

    retval = SC_FUNC_SUCCESS;

finish:
    SC_FREE(c0, sizeof(DOUBLE) * 11 * n);

    return retval;
}


#ifdef DEBUG_ENCRYPTION
static SINT32 gaussian_lattice_sample_debug(safecrypto_t *sc,
    const gpv_t *gpv, const GSO_TYPE *b_gs, const GSO_TYPE *b_gs_inv_norm,
    const SINT32 *c, SINT32 *v,
    UINT32 q, DOUBLE s_f, UINT32 flags)
{
    size_t i, j;
    size_t n = gpv->n;

    const SINT32 *w        = sc->dlp_ibe->params->w;
    const SINT32 *r        = sc->dlp_ibe->params->r;
    ntt_params_t *ntt      = &sc->dlp_ibe->ntt;
    const utils_arith_ntt_t *sc_ntt = sc->dlp_ibe->sc_ntt;
    const utils_arith_poly_t *sc_poly  = sc->dlp_ibe->sc_poly;

    // Verification - prove that ((s1 - t)*f + g*s2) = 0
    SINT32 *t = SC_MALLOC(sizeof(SINT32) * 4 * n);
    SINT32 *s1, *s2, *f, *g;
    SINT32 deg;
    s1 = t;
    s2 = t + n;
    f = t + 2 * n;
    g = t + 3 * n;
    for (j=0; j<n; j++) {
        s1[j] = (SINT32) ci[j];
        s2[j] = v[j];
        f[j] = -gpv->b[n+j];
        g[j] = gpv->b[j];
    }

    sc_poly->sub_single_32(s1, n, c);

    // Verification without NTT
    sc_poly_mpz_t pf, pg;
    sc_poly_mpz_t mp_f, mp_g, mp_h;
    sc_poly_mpz_t temp;
    sc_poly_mpz_init(&temp, 2*n);
    sc_poly_mpz_init(&pf, n);
    sc_poly_mpz_init(&pg, n);
    sc_poly_mpz_init(&mp_f, n);
    sc_poly_mpz_init(&mp_g, n);
    sc_poly_mpz_init(&mp_h, n);

    poly_si32_to_mpi(&mp_f, n, f);
    poly_si32_to_mpi(&mp_g, n, g);
    poly_si32_to_mpi(&mp_h, n, sc->pubkey->key);
    poly_si32_to_mpi(&pf, n, s1);
    poly_si32_to_mpi(&pg, n, s2);

    sc_mod_t mod;
    limb_mod_init(&mod, sc->dlp_ibe->params->q);

    sc_poly_mpz_mul(&temp, &pf, &mp_f);
    sc_poly_mpz_addmul(&temp, &pg, &mp_g);      // (s1 - c)*f + s2*g
    sc_poly_mpz_mod_ring(&temp, n, &temp);
    sc_poly_mpz_mod(&temp, &temp, &mod);
    SINT32 deg_mpi_1 = sc_poly_mpz_degree(&temp);

    sc_poly_mpz_mul(&temp, &pg, &mp_h);
    sc_poly_mpz_add(&temp, &temp, &pf);      // (s1 - c) + s2*h
    sc_poly_mpz_mod_ring(&temp, n, &temp);
    sc_poly_mpz_mod(&temp, &temp, &mod);
    SINT32 deg_mpi_2 = sc_poly_mpz_degree(&temp);

    // Verification with NTT - (s1 - c)*f + s2*g
    sc_ntt->fwd_ntt_32_32_large(s1, ntt, s1, w);
    sc_ntt->fwd_ntt_32_32_large(s2, ntt, s2, w);
    sc_ntt->fwd_ntt_32_32_large(f, ntt, f, w);
    sc_ntt->fwd_ntt_32_32_large(g, ntt, g, w);

    sc->dlp_ibe->sc_ntt->mul_32_pointwise(s1, ntt, s1, f); // NTT(s1 - c) * NTT(f)
    sc->dlp_ibe->sc_ntt->mul_32_pointwise(s2, ntt, s2, g); // NTT(s2) * NTT(g)
    sc_ntt->inv_ntt_32_32_large(s1, ntt, s1, w, r);
    sc_ntt->inv_ntt_32_32_large(s2, ntt, s2, w, r);
    sc_poly->add_32(f, n, s1, s2);
    sc_ntt->normalize_32(f, n, ntt);
    deg = poly_32_degree(f, n);

    if (!(0 == deg && 0 == f[deg])) {
        SC_FREE(t, sizeof(SINT32) * 4 * n);

        sc_poly_mpz_clear(&temp);
        sc_poly_mpz_clear(&pf);
        sc_poly_mpz_clear(&pg);
        sc_poly_mpz_clear(&mp_f);
        sc_poly_mpz_clear(&mp_g);
        sc_poly_mpz_clear(&mp_h);

        goto restart;
    }

    SC_PRINT_1D_INT32(sc, SC_LEVEL_DEBUG, "(s1-c)*f + s2*g", s1, n);

    SC_FREE(t, sizeof(SINT32) * 4 * n);

    sc_poly_mpz_clear(&temp);
    sc_poly_mpz_clear(&pf);
    sc_poly_mpz_clear(&pg);
    sc_poly_mpz_clear(&mp_f);
    sc_poly_mpz_clear(&mp_g);
    sc_poly_mpz_clear(&mp_h);

    return SC_FUNC_SUCCESS;
}
#endif

